<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mdsine2.pylab.cluster API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdsine2.pylab.cluster</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import logging
import copy
import numba
from  orderedset import OrderedSet

# Typing
from typing import TypeVar, Generic, Any, Union, Dict, Iterator, Tuple, Type

from . import util
from .errors import NeedToImplementError
from .graph import Node
from .base import isclusterable, Traceable, TaxaSet
from .graph import Node
from .variables import Variable, summary

# Constants
DEFAULT_CLUSTERVALUE_DTYPE = float

def isclustering(x: Any) -&gt; bool:
    &#39;&#39;&#39;Type check if `x` is a subclass of Clustering

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of Clustering
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, Clustering)

def isclusterproperty(x: Any) -&gt; bool:
    &#39;&#39;&#39;Type check if `x` is a subclass of ClusterProperty

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of ClusterProperty
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, ClusterProperty)

def isclustervalue(x: Any) -&gt; bool:
    &#39;&#39;&#39;Type check if `x` is a subclass of ClusterValue

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of ClusterValue
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, ClusterValue)


class Clustering(Node, Traceable):
    &#39;&#39;&#39;Base class for clustering. This will cluster items where the aggregate
    clas inherits the `pylab.base.Clusterable` class.
    
    Maps a unique cluster id (int) to a cluster object:
        members : set
            Which itemss are assigned to this cluster (using their 
            index specified in `items`)
        id : int
            Python ID of the cluster
        size : int
            How many members are in the cluster

    Accessing and moving items
    --------------------------
    It is strongly recommended that you only reassign an item from one cluster to
    another cluster with the inner functions and do not do it manually by
    directly accessing `self.clusters`. This is for 2 reasons: 
    
    (1) Calling the inner functions to change the cluster assignment also signals 
    the properties assigned to this clusters so everything is kept synchronized 
    with each other. 
    
    (2) there is no possibility that you can delete an item from the system if you 
    use the inner functions. If you were to manually manipulate `self.clusters` 
    and accidentally delete an item, the whole system would crash not know what to 
    do.

    Properties
    ----------
    There might be properties associated with this class. A property is signaled
    when either the cluster assignment of the items change or if a cluster 
    got deleted and/or added. THE PRIORITY OF A CLUSTER BEING DELETED SUPERCEDES
    THE PRIORITY OF AN ITEM BEING MOVED.
    Example:
    - clusters = [1,0,0,0,2,2,2]
    - If we moved oidx `0` to a different cluster using `move_item`:
    - clusters = [0,0,0,0,1,1,1]
    - Our signaling will call the function `clusters_changed`, even though
        item `0` &#34;effectively&#34; moved and there was a deletion of a cluster.

    Example:
    - clusters = [1,0,0,0,2,2,2]
    - If we moved oidx `1` to cluster [0] `move_item`: 
    - clusters = [1,1,0,0,2,2,2]
    - Our signaling will call the function `assignments_changed` because 
      there was no deletion and/or additions of clusters

    Tracing
    -------
    There are two variables that get traced. (1) `coclusters` (len(items) x len(items) matrix) 
    records which items were in the same cluster together at each iteration.
    (2) `n_clusters` (int) records the number of clusters that were at each iteration.
    
    Parameters
    ----------
    clusters : np.ndarray(n_taxa), None
        If None, do not set cluster assignments.
        The index of the array corresponds to the item index. The value of the
        index indicates the cluster for it to be assigned to
    items : pylab.base.Clusterable
        This is the object that stores all of the information of the items. The 
        ordering of the items in this object are assumed to be the global ordering
        and that they do not change when this Object is instantiated
    kwargs : dict
        These are the additional arguments for the Node class (name, Graph, etc.)
    &#39;&#39;&#39;
    def __init__(self, clusters: np.ndarray, items: TaxaSet, **kwargs):
        Node.__init__(self, **kwargs)
        if not isclusterable(items):
            raise TypeError(&#39;`items` ({}) must be a pylab.base.Clusterable object&#39;.format( 
                type(items)))
        if clusters is None:
            clusters = np.arange(len(items))
        elif not util.isarray(clusters):
            raise TypeError(&#39;`clusters` ({}) must either be None or an array&#39;.format( 
                type(clusters)))
        else:
            clusters = np.asarray(clusters)
            if np.any(clusters &lt; 0):
                raise ValueError(&#39;All cluster indices must be &gt; 0&#39;)
            for i in range(np.max(clusters)):
                if i not in clusters:
                    raise ValueError(&#39;Cluster {} not specified in `clusters`&#39;.format(i))
            if len(clusters) != len(items):
                raise ValueError(&#39;`clusters` ({}) must be the same length as `items` ({})&#39;.format(
                    len(clusters), len(items)))
        
        # Everything is good, make the cluster objects
        self._CIDX = 100100 # Start of the cluster index
        self.items = items # This is usually a TaxaSet object
        self.clusters = {} # dict: cluster id (int) -&gt; _Cluster
        for cidx in np.arange(np.max(clusters)+1):
            idxs = np.where(clusters == cidx)[0]
            temp = _Cluster(members=idxs, parent=self, iden=self._CIDX)
            self.clusters[temp.id] = temp
            self._CIDX += 1

        self.order = list(self.clusters) # list of ids
        self.properties = _ClusterProperties() # properties of the clustering
        
        # Maps the item index to the cluster ID it is assigned to
        self.idx2cid = np.zeros(len(self.items), dtype=np.int64)
        for idx in range(len(self.items)):
            for cluster in self:
                if idx in cluster:
                    self.idx2cid[idx] = cluster.id

        # Maps the cluster ID to the cluster index
        self.cid2cidx = {}
        for cidx, cid in enumerate(self.order):
            self.cid2cidx[cid] = cidx

        # Make the tracing objects
        self.coclusters = Variable(
            name=&#39;{}_coclusters&#39;.format(self.name),
            shape=(len(self.items), len(self.items)),
            dtype=bool, G=self.G, value=self.generate_coclusters())
        self.n_clusters = Variable(
            name=&#39;{}_n_clusters&#39;.format(self.name), dtype=int, 
            G=self.G, value=len(clusters))

        # Make the inner lists for the properties
        self._cids_added = []
        self._cids_removed = []

    def __iter__(self) -&gt; &#34;_Cluster&#34;:
        &#39;&#39;&#39;Return each cluster
        &#39;&#39;&#39;
        for key in self.order:
            yield self.clusters[key]
    
    def __str__(self) -&gt; str:
        s = self.name + &#39;, n_clusters: {}&#39;.format(len(self))
        for cluster in self:
            s += &#39;\n{}&#39;.format(str(cluster))
        return s

    def __len__(self) -&gt; int:
        &#39;&#39;&#39;How many clusters

        Returns
        -------
        int
        &#39;&#39;&#39;
        return len(self.order)

    def __contains__(self, cid: int) -&gt; bool:
        return (cid in self.clusters) or (cid &lt; len(self.clusters))

    def __getitem__(self, cid):
        if cid in self.clusters:
            return self.clusters[cid]
        elif cid &lt; len(self.clusters):
            return self.clusters[self.order[cid]]
        else:
            raise KeyError(&#39;`{}` not recognized as an ID or index&#39;.format(cid))

    def keys(self) -&gt; Iterator[int]:
        &#39;&#39;&#39;Alias for `self.order`

        Returns
        -------
        list(shape=(len(items)), dtype=int)
        &#39;&#39;&#39;
        return self.order

    def make_new_cluster_with(self, idx: int) -&gt; int:
        &#39;&#39;&#39;Create a new cluster with the item index `idx`.
        Removes `idx` from the previous cluster.

        If you want a custom function to initialize the values and indicator variables
        for the new cluster, pass in the functions as parameters. If not, it will
        use the defualt that was used during initialization

        Parameters
        ----------
        idx : int
            This is the index of the item to make a new cluster with

        Returns
        -------
        int
            This is the ID of the new cluster that was created
        &#39;&#39;&#39;
        old_cid = self.idx2cid[idx]
        self.clusters[old_cid].remove(idx)
        if self.clusters[old_cid].size == 0:
            # Delete the cluster
            self.clusters.pop(old_cid, None)
            self._cids_removed.append(old_cid)
        
        temp = _Cluster(members=[idx], parent=self, iden=self._CIDX)
        self._CIDX += 1
        self.clusters[temp.id] = temp
        self.idx2cid[idx] = temp.id
        self._cids_added.append(temp.id)
        self.order = list(self.clusters)
        self.n_clusters.value = len(self.clusters)

        self.cid2cidx = {}
        for cidx, cid in enumerate(self.order):
            self.cid2cidx[cid] = cidx

        # Signal to the cluster properties
        for prop in self.properties.signal_when_clusters_change:
            prop.clusters_changed(
                cids_added=self._cids_added,
                cids_removed=self._cids_removed)
        self._cids_added = []
        self._cids_removed = []

        return temp.id

    def move_item(self, idx: int, cid: int) -&gt; int:
        &#39;&#39;&#39;Move `idx` to cluster id `cid`. If `cid` does not exist, then we 
        will create a new cluster.

        Paramters
        ---------
        idx : int
            This is the index of the item to move clusters
        cid : int
            This is the Cluster ID to move `idx` to

        Returns
        -------
        int
            This is the cluster ID it was moved to
        &#39;&#39;&#39;
        if cid not in self:
            return self.make_new_cluster_with(idx)

        # get the id of the cluster (could be an index)
        cid = self[cid].id

        curr_cid = self.idx2cid[idx]
        if cid == curr_cid:
            # Do nothing
            return cid
        
        self.clusters[curr_cid].remove(idx)
        old_cluster_deleted = False
        if self.clusters[curr_cid].size == 0:
            old_cluster_deleted = True
            self.clusters.pop(curr_cid, None)
            self._cids_removed.append(curr_cid)

        self.clusters[cid].add(idx)
        self.idx2cid[idx] = cid
        self.order = list(self.clusters)
        self.cid2cidx = {}
        for cidx, cid in enumerate(self.order):
            self.cid2cidx[cid] = cidx
        self.n_clusters.value = len(self)

        if old_cluster_deleted:
            # Signal `clusters_changed`
            for prop in self.properties.signal_when_clusters_change:
                prop.clusters_changed(
                    cids_added=[],
                    cids_removed=self._cids_removed)
        else:
            # Signal `assignments_changed`
            for prop in self.properties.signal_when_item_assignment_changes:
                prop.assignments_changed()

        self._cids_removed = []
        self._cids_added = []
        return cid
        
    def merge_clusters(self, cid1, cid2):
        raise NotImplementedError(&#39;Not Implemented&#39;)

    def split_cluster(self, cid, members1, members2):
        raise NotImplementedError(&#39;Not Implemented&#39;)

    def generate_coclusters(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Make the cocluster matrix of the current cluster configuration
        &#39;&#39;&#39;
        return _generate_coclusters_fast(idx2cid=self.idx2cid)
    
    def tolistoflists(self) -&gt; Iterator[Iterator[int]]:
        &#39;&#39;&#39;Converts clusters into array format:
        clusters = [clus1, ..., clusN],
            clusters{i} = [idx1, ..., idxM]
        each clusters{i} is a list of indices that are in that cluster

        This is the same format was the input parameter for `__init__`
        
        Returns
        -------
        list
            This is the array of values with the correct order 
        &#39;&#39;&#39;
        ret = []
        for cluster in self:
            ret.append(list(cluster.members))
        return ret

    def toarray(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Converts clusters into array format:
        Each index is the index of an element that is being clustered. The value
        is the cluster index. This is the same format was the input parameter for 
        `__init__`.
        
        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        ret = np.zeros(len(self.items),dtype=int)
        for cidx, cluster in enumerate(self):
            for idx in cluster.members:
                ret[idx] = cidx
        return ret

    def from_array(self, a: np.ndarray):
        &#39;&#39;&#39;Set the clustering from a numpy array - note that this resets
        all of the properties of these clusterings

        Parameters
        ----------
        a : np.ndarray
            The cluster configuration
        &#39;&#39;&#39;
        # Check
        if not util.isarray(a):
            raise TypeError(&#39;`a` ({}) must be an array&#39;.format(type(a)))
        a = np.asarray(a)
        if np.any(a &lt; 0):
            raise ValueError(&#39;All values in `a` must be &gt;= 0&#39;)
        for i in range(np.max(a)):
            if i not in a:
                raise ValueError(&#39;Index `{}` skipped in a&#39;.format(i))
        
        for cidx in range(np.max(a)+1):
            idxs = np.where(a == cidx)[0]
            cid = self.make_new_cluster_with(idxs[0])
            for idx in idxs[1:]:
                self.move_item(idx, cid=cid)

    def set_trace(self, *args, **kwargs):
        &#39;&#39;&#39;Set the trace of the cocluster and n_clusters
        &#39;&#39;&#39;
        self.coclusters.set_trace(*args, **kwargs)
        self.n_clusters.set_trace(*args, **kwargs)

    def add_trace(self):
        &#39;&#39;&#39;Add a trace of the cocluster and n_clusters
        &#39;&#39;&#39;
        self.coclusters.value = self.generate_coclusters()
        self.coclusters.add_trace()
        self.n_clusters.add_trace()


class _Cluster:
    &#39;&#39;&#39;Class for a single cluster.

    Parameters
    ----------
    members : array_like, set
        Individual item indices that are within the cluster
    parent : pylab.Clustering
        Pointer to parent 
    iden : int
        Identifier
    &#39;&#39;&#39;
    def __init__(self, members: Iterator[int], parent: Clustering, iden: int):
        self.members = OrderedSet()
        for mem in members:
            self.members.add(mem)
        self.id = iden # Unique id for class
        self.size = len(members)
        self.parent = parent
                
    def __str__(self) -&gt; str:
        return &#39;Cluster {}\n&#39; \
            &#39;\tmembers: {}\n&#39; \
            &#39;\tsize: {}&#39;.format(
                self.id,
                [self.parent.items[idx].cluster_str() for idx in self.members],
                self.size)

    def __contains__(self, item: Any) -&gt; bool:
        &#39;&#39;&#39;For the `in` operator
        &#39;&#39;&#39;
        return item in self.members

    def __len__(self) -&gt; int:
        return self.size

    def __iter__(self) -&gt; int:
        &#39;&#39;&#39;Let c = ClusterBase object.
        Let c[i] (c.clusters[i]) be this object.
        This method is useful for doing the command:
            `for idx in c[i]`
        That call iterates over every member that this cluster contains
        &#39;&#39;&#39;
        for item in self.members:
            yield item

    def add(self, item: int) -&gt; bool:
        &#39;&#39;&#39;Add the item `item` to the cluster

        Paramters
        ---------
        item : int
            This is the index of the item that we want to add

        Returns
        -------
        bool
            True if successful
        &#39;&#39;&#39;
        if item in self.members:
            return True
        self.members.add(item)
        self.size += 1
        return True

    def remove(self, item: int) -&gt; bool:
        &#39;&#39;&#39;Returns True if `item` was deleted from the cluster. Returns False
        if `item` was not in the cluster so it could not be deleted.

        Paramters
        ---------
        item : int
            This is the index of the item that we want to remove

        Returns
        -------
        bool
            True if the item is contained in the cluster
            False if the item is not contained
        &#39;&#39;&#39;
        if item in self.members:
            self.members.remove(item)
            self.size -= 1
            return True
        return False


class _ClusterProperties:
    &#39;&#39;&#39;Manages the properties associated with the clusters
    &#39;&#39;&#39;
    def __init__(self):
        self._d = {} # ID of object (int) -&gt; ClusterProperty

        # A list of cluster properties to update when a cluster
        # is added or removed
        self.signal_when_clusters_change = [] 

        # A list of cluster properties to update when the assignment
        # of a cluster changes
        self.signal_when_item_assignment_changes = []

        # Local pointer of the keys
        self._keys = []

    def __len__(self) -&gt; int:
        return len(self._keys)

    def __getitem__(self, key: int) -&gt; &#39;ClusterProperty&#39;:
        return self._d[key]

    def __iter__(self) -&gt; &#39;ClusterProperty&#39;:
        for a in self._keys:
            yield self._d[a]

    def add(self, prop: &#39;ClusterProperty&#39;):
        &#39;&#39;&#39;Add a property to the list of cluster properties. Additionally, add the property
        to any of the required lists

        Parameters
        ----------
        prop : ClusterProperty
            ClusterProperty to add
        &#39;&#39;&#39;
        self._d[prop.id] = prop
        if prop.signal_when_clusters_change:
            self.signal_when_clusters_change.append(prop)
        if prop.signal_when_item_assignment_changes:
            self.signal_when_item_assignment_changes.append(prop)
        self._keys = list(self._d.keys())

    def toarray(self) -&gt; Iterator[&#39;ClusterProperty&#39;]:
        &#39;&#39;&#39;Make a list of the ClusterProperty&#39;s.
        &#39;&#39;&#39;
        return [self._d[key] for key in self._keys]

    def keys(self) -&gt; Iterator[int]:
        return self._keys


class ClusterProperty:
    &#39;&#39;&#39;This is a class that stores the property of a set of clusters. The point
    of this class to provide methods of signaling to the cluster property when
    a cluster is added/removed or when the cluster assignment of an item changes. 
    You must inherit this class and implement the `cluster_removed` and 
    `cluster_added` manually.

    An example of this is the ClusterPerturbation class in pylab.contrib - 
    when a cluster is added/removed it must change the size of the indicator 
    object associated with it.

    Parameters
    ----------
    clustering : Clustering
        This is the clustering object
    signal_when_clusters_change : bool
        Set this to True if you want to signal this property when the number
        of clusters change/change cids
    signal_when_item_assignment_changes : bool
        Set to True if you want this property to be signaled when an item
        assignment changes but there is not necessarily a change in the number 
        of clusters/cluster ids
    &#39;&#39;&#39;
    def __init__(self, clustering: Clustering, signal_when_clusters_change: bool,
        signal_when_item_assignment_changes: bool):
        if not isclustering(clustering):
            raise ValueError(&#39;`clustering` ({}) must be a Clustering object&#39;.format(
                type(clustering)))
        if not util.isbool(signal_when_clusters_change):
            raise ValueError(&#39;`signal_when_clusters_change` ({}) must be a bool&#39;.format(
                type(signal_when_clusters_change)))
        if not util.isbool(signal_when_item_assignment_changes):
            raise ValueError(&#39;`signal_when_item_assignment_changes` ({}) must be a bool&#39;.format(
                type(signal_when_item_assignment_changes)))
        self.clustering = clustering
        self.signal_when_clusters_change = signal_when_clusters_change
        self.signal_when_item_assignment_changes = signal_when_item_assignment_changes
        self.clustering.properties.add(self)

    def assignments_changed(self):
        &#39;&#39;&#39;Each object inheriting this class needs to implement this function
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def clusters_changed(self, cids_added, cids_removed):
        &#39;&#39;&#39;Each object inheriting this class needs to implement this function
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def set_signal_when_clusters_change(self, value: bool):
        &#39;&#39;&#39;Switch the signal `signal_when_clusters_change` to `value`

        Paramters
        ---------
        value : bool
            This is what to set the `signal_when_clusters_change` flag to
        &#39;&#39;&#39;
        if not util.isbool(value):
            raise ValueError(&#39;`value` ({}) must be a bool&#39;.format(
                type(value)))
        # Only need to change if they are different
        if self.signal_when_clusters_change != value:
            if self.signal_when_clusters_change:
                # We need to take it out
                self.clustering.properties.signal_when_clusters_change.remove(self)
            else:
                self.clustering.properties.signal_when_clusters_change.append(self)
        self.signal_when_clusters_change = value
        self.reset()

    def set_signal_when_item_assignment_changes(self, value: bool):
        &#39;&#39;&#39;Switch the signal `signal_when_item_assignment_changes` to `value`

        Paramters
        ---------
        value : bool
            This is what to set the `signal_when_item_assignment_changes` flag to
        &#39;&#39;&#39;
        if not util.isbool(value):
            raise ValueError(&#39;`value` ({}) must be a bool&#39;.format(
                type(value)))
        # Only need to chagne if they are different
        if self.signal_when_item_assignment_changes != value:
            if self.signal_when_item_assignment_changes:
                # We need to take it out
                self.clustering.properties.signal_when_item_assignment_changes.remove(self)
            else:
                self.clustering.properties.signal_when_item_assignment_changes.append(self)
        self.signal_when_item_assignment_changes = value
        self.reset()

    def reset(self):
        &#39;&#39;&#39;Call this function after you set the `signal_when_item_assignment_changes` or
        `signal_when_clusters_change`.
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)


class ClusterValue(ClusterProperty, Node, Traceable):
    &#39;&#39;&#39;This is an object that has a value per cluster.
    The value is a dictionary, then there are functions to convert
    that dictionary into an item array or a cluster array.
    This records the data on an item-item basis.

    User nees to implement the signaling methods and reset if necessary

    Parameters
    ----------
    clustering : Clustering
        This is the clustering object you are adding it to
    signal_when_clusters_change : bool
        Flag for ClusterProperty
    signal_when_item_assignment_changes : bool
        Flag for ClusterProperty
    dtype : type
        This is the datatype to set the output to
    kwargs : dict
        These are the extra arguements for Node
    &#39;&#39;&#39;
    def __init__(self, clustering: Clustering, signal_when_clusters_change: bool,
        signal_when_item_assignment_changes: bool, dtype: Type=None, **kwargs):
        if dtype is None:
            dtype = DEFAULT_CLUSTERVALUE_DTYPE
        Node.__init__(self, **kwargs)
        self.value = {}
        self.dtype = dtype
        ClusterProperty.__init__(self, clustering=clustering,
            signal_when_clusters_change=signal_when_clusters_change,
            signal_when_item_assignment_changes=signal_when_item_assignment_changes)
        for cid in self.clustering.order:
            self.value[cid] = np.nan

    def item_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Converts these values per item

        Returns
        -------
        np.ndarray((n,), dtype=self.dtype)
            Array of the values expanded to the items in the overall item order
            specified in Clusterable
        &#39;&#39;&#39;
        ret = np.zeros(len(self.clustering.items), dtype=self.dtype)
        for cluster in self.clustering:
            idxs = list(cluster.members)
            ret[idxs] = self.value[cluster.id]
        return ret

    def cluster_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Converts the dictionary into a cluster array in the order of the clusters

        Returns
        -------
        np.ndarray((n,), dtype=self.dtype)
            Array of the values expanded for each cluster in the overall cluster order
        &#39;&#39;&#39;
        return np.asarray([self.value[cid] for cid in self.clustering.order], dtype=self.dtype)

    def set_values_from_array(self, values: Iterator[Any]):
        &#39;&#39;&#39;Set the values from an array of the same order as the clusters

        Paramters
        ---------
        values : array_like
            An array of the values
            Must be the same length as the number of clusters
        &#39;&#39;&#39;
        if not util.isarray(values):
            raise ValueError(&#39;`values` ({}) must be an array&#39;.format(type(values)))
        if len(values) != len(self.clustering):
            raise ValueError(&#39;`values` ({}) must be the same length as the number &#39; \
                &#39;of clusters ({})&#39;.format(len(values), len(self.clustering)))
        self.value = {}
        for cidx, cid in enumerate(self.clustering.order):
            self.value[cid] = values[cidx]

    def set_trace(self):
        &#39;&#39;&#39;Set up the trace of the object
        &#39;&#39;&#39;
        tracer = self.G.tracer
        tracer.set_trace(
            self.name, 
            shape=(len(self.clustering.items), ), 
            dtype=self.dtype)
        self.ckpt_iter = 0
        self.sample_iter = 0
        self.trace = np.full(shape=(tracer.checkpoint, len(self.clustering.items)),
            dtype=self.dtype, fill_value=np.nan)
    
    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def add_trace(self):
        &#39;&#39;&#39;Adds the current value to the trace on an item-basis. Writes to disk if
        local buffer is full
        &#39;&#39;&#39;
        value = self.item_array()
        self.trace[self.ckpt_iter] = value
        self.ckpt_iter += 1
        self.sample_iter += 1
        if self.ckpt_iter == len(self.trace):
            # We have gotten the largest we can in the local buffer, write to disk
            self.G.tracer.write_to_disk(name=self.name)
            self.trace = np.full(shape=(self.G.tracer.checkpoint, len(self.clustering.items)),
                dtype=self.dtype, fill_value=np.nan)
            self.ckpt_iter = 0


@numba.jit(nopython=True) #, fastmath=True, cache=True)
def _generate_coclusters_fast(idx2cid: np.ndarray) -&gt; np.ndarray:
    &#39;&#39;&#39;Generates a cocluster matrix for the current cluster assignment.
    If two elements are in the same cluster, then the assignment is 1
    If two elements are in different clusters, then the assignment is 0

    A single element is in the same cluster as itself always, so the assignment
    for this is always 1 on the diagonal.

    The elemets are in the order of the elements in `idx2cid`

    Parameters
    ----------
    idx2cid : np.ndarray(shape=(len(items),), dtype=int)
        Each index (corresponds to an item index) maps to the cluster ID

    Returns
    -------
    np.ndarray(shape=(len(items), len(items)))
    &#39;&#39;&#39;
    n_items = len(idx2cid)
    ret = np.zeros(shape=(n_items, n_items), dtype=np.int64)
    for i in range(n_items):
        for j in range(i):
            if idx2cid[i] == idx2cid[j]:
                ret[i,j] = 1
                ret[j,i] = 1
        ret[i,i] = 1
    return ret

@numba.jit(nopython=True, cache=True)
def toarray_from_cocluster(coclusters: np.ndarray) -&gt; np.ndarray:
    &#39;&#39;&#39;Generate the output that would be given from 
    `clustering.toarray` from the cocluster matrix.

    Numba is about 10X faster.

    Example:
        ```
        &gt;&gt;&gt; coclusters = np.asarray(
            [[1,0,0,1],
             [0,1,0,0],
             [0,0,1,0],
             [1,0,0,1]])
        &gt;&gt;&gt; toarray_from_coclusters(coclusters)
        [0, 1, 2, 0]
        ```

    Parameters
    ----------
    coclusters : 2-dim square np.ndarray
        Cocluster matrix
    
    Returns
    -------
    np.ndarray
    &#39;&#39;&#39;
    a = np.full(coclusters.shape[0], -1)
    i = 0
    for j in range(coclusters.shape[0]):
        if a[j] == -1:
            for k in range(j,coclusters.shape[0]):
                if coclusters[j,k] == 1:
                    a[k] = i
            i += 1
    return a</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mdsine2.pylab.cluster.isclustering"><code class="name flex">
<span>def <span class="ident">isclustering</span></span>(<span>x: Any) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Type check if <code>x</code> is a subclass of Clustering</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Returns True if <code>x</code> is a subclass of Clustering</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is the correct subtype</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isclustering(x: Any) -&gt; bool:
    &#39;&#39;&#39;Type check if `x` is a subclass of Clustering

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of Clustering
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, Clustering)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.isclusterproperty"><code class="name flex">
<span>def <span class="ident">isclusterproperty</span></span>(<span>x: Any) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Type check if <code>x</code> is a subclass of ClusterProperty</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Returns True if <code>x</code> is a subclass of ClusterProperty</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is the correct subtype</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isclusterproperty(x: Any) -&gt; bool:
    &#39;&#39;&#39;Type check if `x` is a subclass of ClusterProperty

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of ClusterProperty
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, ClusterProperty)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.isclustervalue"><code class="name flex">
<span>def <span class="ident">isclustervalue</span></span>(<span>x: Any) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Type check if <code>x</code> is a subclass of ClusterValue</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Returns True if <code>x</code> is a subclass of ClusterValue</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is the correct subtype</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isclustervalue(x: Any) -&gt; bool:
    &#39;&#39;&#39;Type check if `x` is a subclass of ClusterValue

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of ClusterValue
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, ClusterValue)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.toarray_from_cocluster"><code class="name flex">
<span>def <span class="ident">toarray_from_cocluster</span></span>(<span>coclusters: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the output that would be given from
<code>clustering.toarray</code> from the cocluster matrix.</p>
<p>Numba is about 10X faster.</p>
<h2 id="example">Example</h2>
<pre><code>```python-repl
&gt;&gt;&gt; coclusters = np.asarray(
    [[1,0,0,1],
     [0,1,0,0],
     [0,0,1,0],
     [1,0,0,1]])
&gt;&gt;&gt; toarray_from_coclusters(coclusters)
[0, 1, 2, 0]
</code></pre>
<p>```</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coclusters</code></strong> :&ensp;<code>2-dim square np.ndarray</code></dt>
<dd>Cocluster matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(nopython=True, cache=True)
def toarray_from_cocluster(coclusters: np.ndarray) -&gt; np.ndarray:
    &#39;&#39;&#39;Generate the output that would be given from 
    `clustering.toarray` from the cocluster matrix.

    Numba is about 10X faster.

    Example:
        ```
        &gt;&gt;&gt; coclusters = np.asarray(
            [[1,0,0,1],
             [0,1,0,0],
             [0,0,1,0],
             [1,0,0,1]])
        &gt;&gt;&gt; toarray_from_coclusters(coclusters)
        [0, 1, 2, 0]
        ```

    Parameters
    ----------
    coclusters : 2-dim square np.ndarray
        Cocluster matrix
    
    Returns
    -------
    np.ndarray
    &#39;&#39;&#39;
    a = np.full(coclusters.shape[0], -1)
    i = 0
    for j in range(coclusters.shape[0]):
        if a[j] == -1:
            for k in range(j,coclusters.shape[0]):
                if coclusters[j,k] == 1:
                    a[k] = i
            i += 1
    return a</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdsine2.pylab.cluster.ClusterProperty"><code class="flex name class">
<span>class <span class="ident">ClusterProperty</span></span>
<span>(</span><span>clustering: <a title="mdsine2.pylab.cluster.Clustering" href="#mdsine2.pylab.cluster.Clustering">Clustering</a>, signal_when_clusters_change: bool, signal_when_item_assignment_changes: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a class that stores the property of a set of clusters. The point
of this class to provide methods of signaling to the cluster property when
a cluster is added/removed or when the cluster assignment of an item changes.
You must inherit this class and implement the <code>cluster_removed</code> and
<code>cluster_added</code> manually.</p>
<p>An example of this is the ClusterPerturbation class in pylab.contrib -
when a cluster is added/removed it must change the size of the indicator
object associated with it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clustering</code></strong> :&ensp;<code><a title="mdsine2.pylab.cluster.Clustering" href="#mdsine2.pylab.cluster.Clustering">Clustering</a></code></dt>
<dd>This is the clustering object</dd>
<dt><strong><code>signal_when_clusters_change</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set this to True if you want to signal this property when the number
of clusters change/change cids</dd>
<dt><strong><code>signal_when_item_assignment_changes</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to True if you want this property to be signaled when an item
assignment changes but there is not necessarily a change in the number
of clusters/cluster ids</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClusterProperty:
    &#39;&#39;&#39;This is a class that stores the property of a set of clusters. The point
    of this class to provide methods of signaling to the cluster property when
    a cluster is added/removed or when the cluster assignment of an item changes. 
    You must inherit this class and implement the `cluster_removed` and 
    `cluster_added` manually.

    An example of this is the ClusterPerturbation class in pylab.contrib - 
    when a cluster is added/removed it must change the size of the indicator 
    object associated with it.

    Parameters
    ----------
    clustering : Clustering
        This is the clustering object
    signal_when_clusters_change : bool
        Set this to True if you want to signal this property when the number
        of clusters change/change cids
    signal_when_item_assignment_changes : bool
        Set to True if you want this property to be signaled when an item
        assignment changes but there is not necessarily a change in the number 
        of clusters/cluster ids
    &#39;&#39;&#39;
    def __init__(self, clustering: Clustering, signal_when_clusters_change: bool,
        signal_when_item_assignment_changes: bool):
        if not isclustering(clustering):
            raise ValueError(&#39;`clustering` ({}) must be a Clustering object&#39;.format(
                type(clustering)))
        if not util.isbool(signal_when_clusters_change):
            raise ValueError(&#39;`signal_when_clusters_change` ({}) must be a bool&#39;.format(
                type(signal_when_clusters_change)))
        if not util.isbool(signal_when_item_assignment_changes):
            raise ValueError(&#39;`signal_when_item_assignment_changes` ({}) must be a bool&#39;.format(
                type(signal_when_item_assignment_changes)))
        self.clustering = clustering
        self.signal_when_clusters_change = signal_when_clusters_change
        self.signal_when_item_assignment_changes = signal_when_item_assignment_changes
        self.clustering.properties.add(self)

    def assignments_changed(self):
        &#39;&#39;&#39;Each object inheriting this class needs to implement this function
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def clusters_changed(self, cids_added, cids_removed):
        &#39;&#39;&#39;Each object inheriting this class needs to implement this function
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def set_signal_when_clusters_change(self, value: bool):
        &#39;&#39;&#39;Switch the signal `signal_when_clusters_change` to `value`

        Paramters
        ---------
        value : bool
            This is what to set the `signal_when_clusters_change` flag to
        &#39;&#39;&#39;
        if not util.isbool(value):
            raise ValueError(&#39;`value` ({}) must be a bool&#39;.format(
                type(value)))
        # Only need to change if they are different
        if self.signal_when_clusters_change != value:
            if self.signal_when_clusters_change:
                # We need to take it out
                self.clustering.properties.signal_when_clusters_change.remove(self)
            else:
                self.clustering.properties.signal_when_clusters_change.append(self)
        self.signal_when_clusters_change = value
        self.reset()

    def set_signal_when_item_assignment_changes(self, value: bool):
        &#39;&#39;&#39;Switch the signal `signal_when_item_assignment_changes` to `value`

        Paramters
        ---------
        value : bool
            This is what to set the `signal_when_item_assignment_changes` flag to
        &#39;&#39;&#39;
        if not util.isbool(value):
            raise ValueError(&#39;`value` ({}) must be a bool&#39;.format(
                type(value)))
        # Only need to chagne if they are different
        if self.signal_when_item_assignment_changes != value:
            if self.signal_when_item_assignment_changes:
                # We need to take it out
                self.clustering.properties.signal_when_item_assignment_changes.remove(self)
            else:
                self.clustering.properties.signal_when_item_assignment_changes.append(self)
        self.signal_when_item_assignment_changes = value
        self.reset()

    def reset(self):
        &#39;&#39;&#39;Call this function after you set the `signal_when_item_assignment_changes` or
        `signal_when_clusters_change`.
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.cluster.ClusterValue" href="#mdsine2.pylab.cluster.ClusterValue">ClusterValue</a></li>
<li><a title="mdsine2.pylab.contrib.Interactions" href="contrib.html#mdsine2.pylab.contrib.Interactions">Interactions</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.cluster.ClusterProperty.assignments_changed"><code class="name flex">
<span>def <span class="ident">assignments_changed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Each object inheriting this class needs to implement this function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assignments_changed(self):
    &#39;&#39;&#39;Each object inheriting this class needs to implement this function
    &#39;&#39;&#39;
    raise NeedToImplementError(&#39;User needs to implement this function&#39;)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterProperty.clusters_changed"><code class="name flex">
<span>def <span class="ident">clusters_changed</span></span>(<span>self, cids_added, cids_removed)</span>
</code></dt>
<dd>
<div class="desc"><p>Each object inheriting this class needs to implement this function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clusters_changed(self, cids_added, cids_removed):
    &#39;&#39;&#39;Each object inheriting this class needs to implement this function
    &#39;&#39;&#39;
    raise NeedToImplementError(&#39;User needs to implement this function&#39;)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterProperty.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Call this function after you set the <code>signal_when_item_assignment_changes</code> or
<code>signal_when_clusters_change</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#39;&#39;&#39;Call this function after you set the `signal_when_item_assignment_changes` or
    `signal_when_clusters_change`.
    &#39;&#39;&#39;
    raise NeedToImplementError(&#39;User needs to implement this function&#39;)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterProperty.set_signal_when_clusters_change"><code class="name flex">
<span>def <span class="ident">set_signal_when_clusters_change</span></span>(<span>self, value: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Switch the signal <code>signal_when_clusters_change</code> to <code>value</code></p>
<h2 id="paramters">Paramters</h2>
<p>value : bool
This is what to set the <code>signal_when_clusters_change</code> flag to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_signal_when_clusters_change(self, value: bool):
    &#39;&#39;&#39;Switch the signal `signal_when_clusters_change` to `value`

    Paramters
    ---------
    value : bool
        This is what to set the `signal_when_clusters_change` flag to
    &#39;&#39;&#39;
    if not util.isbool(value):
        raise ValueError(&#39;`value` ({}) must be a bool&#39;.format(
            type(value)))
    # Only need to change if they are different
    if self.signal_when_clusters_change != value:
        if self.signal_when_clusters_change:
            # We need to take it out
            self.clustering.properties.signal_when_clusters_change.remove(self)
        else:
            self.clustering.properties.signal_when_clusters_change.append(self)
    self.signal_when_clusters_change = value
    self.reset()</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterProperty.set_signal_when_item_assignment_changes"><code class="name flex">
<span>def <span class="ident">set_signal_when_item_assignment_changes</span></span>(<span>self, value: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Switch the signal <code>signal_when_item_assignment_changes</code> to <code>value</code></p>
<h2 id="paramters">Paramters</h2>
<p>value : bool
This is what to set the <code>signal_when_item_assignment_changes</code> flag to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_signal_when_item_assignment_changes(self, value: bool):
    &#39;&#39;&#39;Switch the signal `signal_when_item_assignment_changes` to `value`

    Paramters
    ---------
    value : bool
        This is what to set the `signal_when_item_assignment_changes` flag to
    &#39;&#39;&#39;
    if not util.isbool(value):
        raise ValueError(&#39;`value` ({}) must be a bool&#39;.format(
            type(value)))
    # Only need to chagne if they are different
    if self.signal_when_item_assignment_changes != value:
        if self.signal_when_item_assignment_changes:
            # We need to take it out
            self.clustering.properties.signal_when_item_assignment_changes.remove(self)
        else:
            self.clustering.properties.signal_when_item_assignment_changes.append(self)
    self.signal_when_item_assignment_changes = value
    self.reset()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterValue"><code class="flex name class">
<span>class <span class="ident">ClusterValue</span></span>
<span>(</span><span>clustering: <a title="mdsine2.pylab.cluster.Clustering" href="#mdsine2.pylab.cluster.Clustering">Clustering</a>, signal_when_clusters_change: bool, signal_when_item_assignment_changes: bool, dtype: Type = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an object that has a value per cluster.
The value is a dictionary, then there are functions to convert
that dictionary into an item array or a cluster array.
This records the data on an item-item basis.</p>
<p>User nees to implement the signaling methods and reset if necessary</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clustering</code></strong> :&ensp;<code><a title="mdsine2.pylab.cluster.Clustering" href="#mdsine2.pylab.cluster.Clustering">Clustering</a></code></dt>
<dd>This is the clustering object you are adding it to</dd>
<dt><strong><code>signal_when_clusters_change</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag for ClusterProperty</dd>
<dt><strong><code>signal_when_item_assignment_changes</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag for ClusterProperty</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code></dt>
<dd>This is the datatype to set the output to</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>These are the extra arguements for Node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClusterValue(ClusterProperty, Node, Traceable):
    &#39;&#39;&#39;This is an object that has a value per cluster.
    The value is a dictionary, then there are functions to convert
    that dictionary into an item array or a cluster array.
    This records the data on an item-item basis.

    User nees to implement the signaling methods and reset if necessary

    Parameters
    ----------
    clustering : Clustering
        This is the clustering object you are adding it to
    signal_when_clusters_change : bool
        Flag for ClusterProperty
    signal_when_item_assignment_changes : bool
        Flag for ClusterProperty
    dtype : type
        This is the datatype to set the output to
    kwargs : dict
        These are the extra arguements for Node
    &#39;&#39;&#39;
    def __init__(self, clustering: Clustering, signal_when_clusters_change: bool,
        signal_when_item_assignment_changes: bool, dtype: Type=None, **kwargs):
        if dtype is None:
            dtype = DEFAULT_CLUSTERVALUE_DTYPE
        Node.__init__(self, **kwargs)
        self.value = {}
        self.dtype = dtype
        ClusterProperty.__init__(self, clustering=clustering,
            signal_when_clusters_change=signal_when_clusters_change,
            signal_when_item_assignment_changes=signal_when_item_assignment_changes)
        for cid in self.clustering.order:
            self.value[cid] = np.nan

    def item_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Converts these values per item

        Returns
        -------
        np.ndarray((n,), dtype=self.dtype)
            Array of the values expanded to the items in the overall item order
            specified in Clusterable
        &#39;&#39;&#39;
        ret = np.zeros(len(self.clustering.items), dtype=self.dtype)
        for cluster in self.clustering:
            idxs = list(cluster.members)
            ret[idxs] = self.value[cluster.id]
        return ret

    def cluster_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Converts the dictionary into a cluster array in the order of the clusters

        Returns
        -------
        np.ndarray((n,), dtype=self.dtype)
            Array of the values expanded for each cluster in the overall cluster order
        &#39;&#39;&#39;
        return np.asarray([self.value[cid] for cid in self.clustering.order], dtype=self.dtype)

    def set_values_from_array(self, values: Iterator[Any]):
        &#39;&#39;&#39;Set the values from an array of the same order as the clusters

        Paramters
        ---------
        values : array_like
            An array of the values
            Must be the same length as the number of clusters
        &#39;&#39;&#39;
        if not util.isarray(values):
            raise ValueError(&#39;`values` ({}) must be an array&#39;.format(type(values)))
        if len(values) != len(self.clustering):
            raise ValueError(&#39;`values` ({}) must be the same length as the number &#39; \
                &#39;of clusters ({})&#39;.format(len(values), len(self.clustering)))
        self.value = {}
        for cidx, cid in enumerate(self.clustering.order):
            self.value[cid] = values[cidx]

    def set_trace(self):
        &#39;&#39;&#39;Set up the trace of the object
        &#39;&#39;&#39;
        tracer = self.G.tracer
        tracer.set_trace(
            self.name, 
            shape=(len(self.clustering.items), ), 
            dtype=self.dtype)
        self.ckpt_iter = 0
        self.sample_iter = 0
        self.trace = np.full(shape=(tracer.checkpoint, len(self.clustering.items)),
            dtype=self.dtype, fill_value=np.nan)
    
    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def add_trace(self):
        &#39;&#39;&#39;Adds the current value to the trace on an item-basis. Writes to disk if
        local buffer is full
        &#39;&#39;&#39;
        value = self.item_array()
        self.trace[self.ckpt_iter] = value
        self.ckpt_iter += 1
        self.sample_iter += 1
        if self.ckpt_iter == len(self.trace):
            # We have gotten the largest we can in the local buffer, write to disk
            self.G.tracer.write_to_disk(name=self.name)
            self.trace = np.full(shape=(self.G.tracer.checkpoint, len(self.clustering.items)),
                dtype=self.dtype, fill_value=np.nan)
            self.ckpt_iter = 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.cluster.ClusterProperty" href="#mdsine2.pylab.cluster.ClusterProperty">ClusterProperty</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator" href="contrib.html#mdsine2.pylab.contrib.ClusterPerturbationIndicator">ClusterPerturbationIndicator</a></li>
<li><a title="mdsine2.pylab.contrib.ClusterPerturbationValue" href="contrib.html#mdsine2.pylab.contrib.ClusterPerturbationValue">ClusterPerturbationValue</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.cluster.ClusterValue.add_trace"><code class="name flex">
<span>def <span class="ident">add_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the current value to the trace on an item-basis. Writes to disk if
local buffer is full</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_trace(self):
    &#39;&#39;&#39;Adds the current value to the trace on an item-basis. Writes to disk if
    local buffer is full
    &#39;&#39;&#39;
    value = self.item_array()
    self.trace[self.ckpt_iter] = value
    self.ckpt_iter += 1
    self.sample_iter += 1
    if self.ckpt_iter == len(self.trace):
        # We have gotten the largest we can in the local buffer, write to disk
        self.G.tracer.write_to_disk(name=self.name)
        self.trace = np.full(shape=(self.G.tracer.checkpoint, len(self.clustering.items)),
            dtype=self.dtype, fill_value=np.nan)
        self.ckpt_iter = 0</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterValue.cluster_array"><code class="name flex">
<span>def <span class="ident">cluster_array</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the dictionary into a cluster array in the order of the clusters</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n,), dtype=self.dtype)</code></dt>
<dd>Array of the values expanded for each cluster in the overall cluster order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_array(self) -&gt; np.ndarray:
    &#39;&#39;&#39;Converts the dictionary into a cluster array in the order of the clusters

    Returns
    -------
    np.ndarray((n,), dtype=self.dtype)
        Array of the values expanded for each cluster in the overall cluster order
    &#39;&#39;&#39;
    return np.asarray([self.value[cid] for cid in self.clustering.order], dtype=self.dtype)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterValue.item_array"><code class="name flex">
<span>def <span class="ident">item_array</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Converts these values per item</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n,), dtype=self.dtype)</code></dt>
<dd>Array of the values expanded to the items in the overall item order
specified in Clusterable</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item_array(self) -&gt; np.ndarray:
    &#39;&#39;&#39;Converts these values per item

    Returns
    -------
    np.ndarray((n,), dtype=self.dtype)
        Array of the values expanded to the items in the overall item order
        specified in Clusterable
    &#39;&#39;&#39;
    ret = np.zeros(len(self.clustering.items), dtype=self.dtype)
    for cluster in self.clustering:
        idxs = list(cluster.members)
        ret[idxs] = self.value[cluster.id]
    return ret</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterValue.remove_local_trace"><code class="name flex">
<span>def <span class="ident">remove_local_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the local trace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_local_trace(self):
    &#39;&#39;&#39;Delete the local trace
    &#39;&#39;&#39;
    self.trace = None</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterValue.set_trace"><code class="name flex">
<span>def <span class="ident">set_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up the trace of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_trace(self):
    &#39;&#39;&#39;Set up the trace of the object
    &#39;&#39;&#39;
    tracer = self.G.tracer
    tracer.set_trace(
        self.name, 
        shape=(len(self.clustering.items), ), 
        dtype=self.dtype)
    self.ckpt_iter = 0
    self.sample_iter = 0
    self.trace = np.full(shape=(tracer.checkpoint, len(self.clustering.items)),
        dtype=self.dtype, fill_value=np.nan)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.ClusterValue.set_values_from_array"><code class="name flex">
<span>def <span class="ident">set_values_from_array</span></span>(<span>self, values: Iterator[Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Set the values from an array of the same order as the clusters</p>
<h2 id="paramters">Paramters</h2>
<p>values : array_like
An array of the values
Must be the same length as the number of clusters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_values_from_array(self, values: Iterator[Any]):
    &#39;&#39;&#39;Set the values from an array of the same order as the clusters

    Paramters
    ---------
    values : array_like
        An array of the values
        Must be the same length as the number of clusters
    &#39;&#39;&#39;
    if not util.isarray(values):
        raise ValueError(&#39;`values` ({}) must be an array&#39;.format(type(values)))
    if len(values) != len(self.clustering):
        raise ValueError(&#39;`values` ({}) must be the same length as the number &#39; \
            &#39;of clusters ({})&#39;.format(len(values), len(self.clustering)))
    self.value = {}
    for cidx, cid in enumerate(self.clustering.order):
        self.value[cid] = values[cidx]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.cluster.ClusterProperty" href="#mdsine2.pylab.cluster.ClusterProperty">ClusterProperty</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.assignments_changed" href="#mdsine2.pylab.cluster.ClusterProperty.assignments_changed">assignments_changed</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.clusters_changed" href="#mdsine2.pylab.cluster.ClusterProperty.clusters_changed">clusters_changed</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.reset" href="#mdsine2.pylab.cluster.ClusterProperty.reset">reset</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.set_signal_when_clusters_change" href="#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_clusters_change">set_signal_when_clusters_change</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.set_signal_when_item_assignment_changes" href="#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_item_assignment_changes">set_signal_when_item_assignment_changes</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.graph.Node.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.base.Traceable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering"><code class="flex name class">
<span>class <span class="ident">Clustering</span></span>
<span>(</span><span>clusters: numpy.ndarray, items: <a title="mdsine2.pylab.base.TaxaSet" href="base.html#mdsine2.pylab.base.TaxaSet">TaxaSet</a>, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for clustering. This will cluster items where the aggregate
clas inherits the <code>pylab.base.Clusterable</code> class.</p>
<p>Maps a unique cluster id (int) to a cluster object:
members : set
Which itemss are assigned to this cluster (using their
index specified in <code>items</code>)
id : int
Python ID of the cluster
size : int
How many members are in the cluster</p>
<h2 id="accessing-and-moving-items">Accessing And Moving Items</h2>
<p>It is strongly recommended that you only reassign an item from one cluster to
another cluster with the inner functions and do not do it manually by
directly accessing <code>self.clusters</code>. This is for 2 reasons: </p>
<p>(1) Calling the inner functions to change the cluster assignment also signals
the properties assigned to this clusters so everything is kept synchronized
with each other. </p>
<p>(2) there is no possibility that you can delete an item from the system if you
use the inner functions. If you were to manually manipulate <code>self.clusters</code>
and accidentally delete an item, the whole system would crash not know what to
do.</p>
<h2 id="properties">Properties</h2>
<p>There might be properties associated with this class. A property is signaled
when either the cluster assignment of the items change or if a cluster
got deleted and/or added. THE PRIORITY OF A CLUSTER BEING DELETED SUPERCEDES
THE PRIORITY OF AN ITEM BEING MOVED.
Example:
- clusters = [1,0,0,0,2,2,2]
- If we moved oidx <code>0</code> to a different cluster using <code>move_item</code>:
- clusters = [0,0,0,0,1,1,1]
- Our signaling will call the function <code>clusters_changed</code>, even though
item <code>0</code> "effectively" moved and there was a deletion of a cluster.</p>
<p>Example:
- clusters = [1,0,0,0,2,2,2]
- If we moved oidx <code>1</code> to cluster [0] <code>move_item</code>:
- clusters = [1,1,0,0,2,2,2]
- Our signaling will call the function <code>assignments_changed</code> because
there was no deletion and/or additions of clusters</p>
<h2 id="tracing">Tracing</h2>
<p>There are two variables that get traced. (1) <code>coclusters</code> (len(items) x len(items) matrix)
records which items were in the same cluster together at each iteration.
(2) <code>n_clusters</code> (int) records the number of clusters that were at each iteration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clusters</code></strong> :&ensp;<code>np.ndarray(n_taxa), None</code></dt>
<dd>If None, do not set cluster assignments.
The index of the array corresponds to the item index. The value of the
index indicates the cluster for it to be assigned to</dd>
<dt><strong><code>items</code></strong> :&ensp;<code>pylab.base.Clusterable</code></dt>
<dd>This is the object that stores all of the information of the items. The
ordering of the items in this object are assumed to be the global ordering
and that they do not change when this Object is instantiated</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>These are the additional arguments for the Node class (name, Graph, etc.)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Clustering(Node, Traceable):
    &#39;&#39;&#39;Base class for clustering. This will cluster items where the aggregate
    clas inherits the `pylab.base.Clusterable` class.
    
    Maps a unique cluster id (int) to a cluster object:
        members : set
            Which itemss are assigned to this cluster (using their 
            index specified in `items`)
        id : int
            Python ID of the cluster
        size : int
            How many members are in the cluster

    Accessing and moving items
    --------------------------
    It is strongly recommended that you only reassign an item from one cluster to
    another cluster with the inner functions and do not do it manually by
    directly accessing `self.clusters`. This is for 2 reasons: 
    
    (1) Calling the inner functions to change the cluster assignment also signals 
    the properties assigned to this clusters so everything is kept synchronized 
    with each other. 
    
    (2) there is no possibility that you can delete an item from the system if you 
    use the inner functions. If you were to manually manipulate `self.clusters` 
    and accidentally delete an item, the whole system would crash not know what to 
    do.

    Properties
    ----------
    There might be properties associated with this class. A property is signaled
    when either the cluster assignment of the items change or if a cluster 
    got deleted and/or added. THE PRIORITY OF A CLUSTER BEING DELETED SUPERCEDES
    THE PRIORITY OF AN ITEM BEING MOVED.
    Example:
    - clusters = [1,0,0,0,2,2,2]
    - If we moved oidx `0` to a different cluster using `move_item`:
    - clusters = [0,0,0,0,1,1,1]
    - Our signaling will call the function `clusters_changed`, even though
        item `0` &#34;effectively&#34; moved and there was a deletion of a cluster.

    Example:
    - clusters = [1,0,0,0,2,2,2]
    - If we moved oidx `1` to cluster [0] `move_item`: 
    - clusters = [1,1,0,0,2,2,2]
    - Our signaling will call the function `assignments_changed` because 
      there was no deletion and/or additions of clusters

    Tracing
    -------
    There are two variables that get traced. (1) `coclusters` (len(items) x len(items) matrix) 
    records which items were in the same cluster together at each iteration.
    (2) `n_clusters` (int) records the number of clusters that were at each iteration.
    
    Parameters
    ----------
    clusters : np.ndarray(n_taxa), None
        If None, do not set cluster assignments.
        The index of the array corresponds to the item index. The value of the
        index indicates the cluster for it to be assigned to
    items : pylab.base.Clusterable
        This is the object that stores all of the information of the items. The 
        ordering of the items in this object are assumed to be the global ordering
        and that they do not change when this Object is instantiated
    kwargs : dict
        These are the additional arguments for the Node class (name, Graph, etc.)
    &#39;&#39;&#39;
    def __init__(self, clusters: np.ndarray, items: TaxaSet, **kwargs):
        Node.__init__(self, **kwargs)
        if not isclusterable(items):
            raise TypeError(&#39;`items` ({}) must be a pylab.base.Clusterable object&#39;.format( 
                type(items)))
        if clusters is None:
            clusters = np.arange(len(items))
        elif not util.isarray(clusters):
            raise TypeError(&#39;`clusters` ({}) must either be None or an array&#39;.format( 
                type(clusters)))
        else:
            clusters = np.asarray(clusters)
            if np.any(clusters &lt; 0):
                raise ValueError(&#39;All cluster indices must be &gt; 0&#39;)
            for i in range(np.max(clusters)):
                if i not in clusters:
                    raise ValueError(&#39;Cluster {} not specified in `clusters`&#39;.format(i))
            if len(clusters) != len(items):
                raise ValueError(&#39;`clusters` ({}) must be the same length as `items` ({})&#39;.format(
                    len(clusters), len(items)))
        
        # Everything is good, make the cluster objects
        self._CIDX = 100100 # Start of the cluster index
        self.items = items # This is usually a TaxaSet object
        self.clusters = {} # dict: cluster id (int) -&gt; _Cluster
        for cidx in np.arange(np.max(clusters)+1):
            idxs = np.where(clusters == cidx)[0]
            temp = _Cluster(members=idxs, parent=self, iden=self._CIDX)
            self.clusters[temp.id] = temp
            self._CIDX += 1

        self.order = list(self.clusters) # list of ids
        self.properties = _ClusterProperties() # properties of the clustering
        
        # Maps the item index to the cluster ID it is assigned to
        self.idx2cid = np.zeros(len(self.items), dtype=np.int64)
        for idx in range(len(self.items)):
            for cluster in self:
                if idx in cluster:
                    self.idx2cid[idx] = cluster.id

        # Maps the cluster ID to the cluster index
        self.cid2cidx = {}
        for cidx, cid in enumerate(self.order):
            self.cid2cidx[cid] = cidx

        # Make the tracing objects
        self.coclusters = Variable(
            name=&#39;{}_coclusters&#39;.format(self.name),
            shape=(len(self.items), len(self.items)),
            dtype=bool, G=self.G, value=self.generate_coclusters())
        self.n_clusters = Variable(
            name=&#39;{}_n_clusters&#39;.format(self.name), dtype=int, 
            G=self.G, value=len(clusters))

        # Make the inner lists for the properties
        self._cids_added = []
        self._cids_removed = []

    def __iter__(self) -&gt; &#34;_Cluster&#34;:
        &#39;&#39;&#39;Return each cluster
        &#39;&#39;&#39;
        for key in self.order:
            yield self.clusters[key]
    
    def __str__(self) -&gt; str:
        s = self.name + &#39;, n_clusters: {}&#39;.format(len(self))
        for cluster in self:
            s += &#39;\n{}&#39;.format(str(cluster))
        return s

    def __len__(self) -&gt; int:
        &#39;&#39;&#39;How many clusters

        Returns
        -------
        int
        &#39;&#39;&#39;
        return len(self.order)

    def __contains__(self, cid: int) -&gt; bool:
        return (cid in self.clusters) or (cid &lt; len(self.clusters))

    def __getitem__(self, cid):
        if cid in self.clusters:
            return self.clusters[cid]
        elif cid &lt; len(self.clusters):
            return self.clusters[self.order[cid]]
        else:
            raise KeyError(&#39;`{}` not recognized as an ID or index&#39;.format(cid))

    def keys(self) -&gt; Iterator[int]:
        &#39;&#39;&#39;Alias for `self.order`

        Returns
        -------
        list(shape=(len(items)), dtype=int)
        &#39;&#39;&#39;
        return self.order

    def make_new_cluster_with(self, idx: int) -&gt; int:
        &#39;&#39;&#39;Create a new cluster with the item index `idx`.
        Removes `idx` from the previous cluster.

        If you want a custom function to initialize the values and indicator variables
        for the new cluster, pass in the functions as parameters. If not, it will
        use the defualt that was used during initialization

        Parameters
        ----------
        idx : int
            This is the index of the item to make a new cluster with

        Returns
        -------
        int
            This is the ID of the new cluster that was created
        &#39;&#39;&#39;
        old_cid = self.idx2cid[idx]
        self.clusters[old_cid].remove(idx)
        if self.clusters[old_cid].size == 0:
            # Delete the cluster
            self.clusters.pop(old_cid, None)
            self._cids_removed.append(old_cid)
        
        temp = _Cluster(members=[idx], parent=self, iden=self._CIDX)
        self._CIDX += 1
        self.clusters[temp.id] = temp
        self.idx2cid[idx] = temp.id
        self._cids_added.append(temp.id)
        self.order = list(self.clusters)
        self.n_clusters.value = len(self.clusters)

        self.cid2cidx = {}
        for cidx, cid in enumerate(self.order):
            self.cid2cidx[cid] = cidx

        # Signal to the cluster properties
        for prop in self.properties.signal_when_clusters_change:
            prop.clusters_changed(
                cids_added=self._cids_added,
                cids_removed=self._cids_removed)
        self._cids_added = []
        self._cids_removed = []

        return temp.id

    def move_item(self, idx: int, cid: int) -&gt; int:
        &#39;&#39;&#39;Move `idx` to cluster id `cid`. If `cid` does not exist, then we 
        will create a new cluster.

        Paramters
        ---------
        idx : int
            This is the index of the item to move clusters
        cid : int
            This is the Cluster ID to move `idx` to

        Returns
        -------
        int
            This is the cluster ID it was moved to
        &#39;&#39;&#39;
        if cid not in self:
            return self.make_new_cluster_with(idx)

        # get the id of the cluster (could be an index)
        cid = self[cid].id

        curr_cid = self.idx2cid[idx]
        if cid == curr_cid:
            # Do nothing
            return cid
        
        self.clusters[curr_cid].remove(idx)
        old_cluster_deleted = False
        if self.clusters[curr_cid].size == 0:
            old_cluster_deleted = True
            self.clusters.pop(curr_cid, None)
            self._cids_removed.append(curr_cid)

        self.clusters[cid].add(idx)
        self.idx2cid[idx] = cid
        self.order = list(self.clusters)
        self.cid2cidx = {}
        for cidx, cid in enumerate(self.order):
            self.cid2cidx[cid] = cidx
        self.n_clusters.value = len(self)

        if old_cluster_deleted:
            # Signal `clusters_changed`
            for prop in self.properties.signal_when_clusters_change:
                prop.clusters_changed(
                    cids_added=[],
                    cids_removed=self._cids_removed)
        else:
            # Signal `assignments_changed`
            for prop in self.properties.signal_when_item_assignment_changes:
                prop.assignments_changed()

        self._cids_removed = []
        self._cids_added = []
        return cid
        
    def merge_clusters(self, cid1, cid2):
        raise NotImplementedError(&#39;Not Implemented&#39;)

    def split_cluster(self, cid, members1, members2):
        raise NotImplementedError(&#39;Not Implemented&#39;)

    def generate_coclusters(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Make the cocluster matrix of the current cluster configuration
        &#39;&#39;&#39;
        return _generate_coclusters_fast(idx2cid=self.idx2cid)
    
    def tolistoflists(self) -&gt; Iterator[Iterator[int]]:
        &#39;&#39;&#39;Converts clusters into array format:
        clusters = [clus1, ..., clusN],
            clusters{i} = [idx1, ..., idxM]
        each clusters{i} is a list of indices that are in that cluster

        This is the same format was the input parameter for `__init__`
        
        Returns
        -------
        list
            This is the array of values with the correct order 
        &#39;&#39;&#39;
        ret = []
        for cluster in self:
            ret.append(list(cluster.members))
        return ret

    def toarray(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Converts clusters into array format:
        Each index is the index of an element that is being clustered. The value
        is the cluster index. This is the same format was the input parameter for 
        `__init__`.
        
        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        ret = np.zeros(len(self.items),dtype=int)
        for cidx, cluster in enumerate(self):
            for idx in cluster.members:
                ret[idx] = cidx
        return ret

    def from_array(self, a: np.ndarray):
        &#39;&#39;&#39;Set the clustering from a numpy array - note that this resets
        all of the properties of these clusterings

        Parameters
        ----------
        a : np.ndarray
            The cluster configuration
        &#39;&#39;&#39;
        # Check
        if not util.isarray(a):
            raise TypeError(&#39;`a` ({}) must be an array&#39;.format(type(a)))
        a = np.asarray(a)
        if np.any(a &lt; 0):
            raise ValueError(&#39;All values in `a` must be &gt;= 0&#39;)
        for i in range(np.max(a)):
            if i not in a:
                raise ValueError(&#39;Index `{}` skipped in a&#39;.format(i))
        
        for cidx in range(np.max(a)+1):
            idxs = np.where(a == cidx)[0]
            cid = self.make_new_cluster_with(idxs[0])
            for idx in idxs[1:]:
                self.move_item(idx, cid=cid)

    def set_trace(self, *args, **kwargs):
        &#39;&#39;&#39;Set the trace of the cocluster and n_clusters
        &#39;&#39;&#39;
        self.coclusters.set_trace(*args, **kwargs)
        self.n_clusters.set_trace(*args, **kwargs)

    def add_trace(self):
        &#39;&#39;&#39;Add a trace of the cocluster and n_clusters
        &#39;&#39;&#39;
        self.coclusters.value = self.generate_coclusters()
        self.coclusters.add_trace()
        self.n_clusters.add_trace()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.cluster.Clustering.add_trace"><code class="name flex">
<span>def <span class="ident">add_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a trace of the cocluster and n_clusters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_trace(self):
    &#39;&#39;&#39;Add a trace of the cocluster and n_clusters
    &#39;&#39;&#39;
    self.coclusters.value = self.generate_coclusters()
    self.coclusters.add_trace()
    self.n_clusters.add_trace()</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.from_array"><code class="name flex">
<span>def <span class="ident">from_array</span></span>(<span>self, a: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the clustering from a numpy array - note that this resets
all of the properties of these clusterings</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The cluster configuration</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_array(self, a: np.ndarray):
    &#39;&#39;&#39;Set the clustering from a numpy array - note that this resets
    all of the properties of these clusterings

    Parameters
    ----------
    a : np.ndarray
        The cluster configuration
    &#39;&#39;&#39;
    # Check
    if not util.isarray(a):
        raise TypeError(&#39;`a` ({}) must be an array&#39;.format(type(a)))
    a = np.asarray(a)
    if np.any(a &lt; 0):
        raise ValueError(&#39;All values in `a` must be &gt;= 0&#39;)
    for i in range(np.max(a)):
        if i not in a:
            raise ValueError(&#39;Index `{}` skipped in a&#39;.format(i))
    
    for cidx in range(np.max(a)+1):
        idxs = np.where(a == cidx)[0]
        cid = self.make_new_cluster_with(idxs[0])
        for idx in idxs[1:]:
            self.move_item(idx, cid=cid)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.generate_coclusters"><code class="name flex">
<span>def <span class="ident">generate_coclusters</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Make the cocluster matrix of the current cluster configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_coclusters(self) -&gt; np.ndarray:
    &#39;&#39;&#39;Make the cocluster matrix of the current cluster configuration
    &#39;&#39;&#39;
    return _generate_coclusters_fast(idx2cid=self.idx2cid)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self) ‑> Iterator[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code>self.order</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list(shape=(len(items)), dtype=int)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self) -&gt; Iterator[int]:
    &#39;&#39;&#39;Alias for `self.order`

    Returns
    -------
    list(shape=(len(items)), dtype=int)
    &#39;&#39;&#39;
    return self.order</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.make_new_cluster_with"><code class="name flex">
<span>def <span class="ident">make_new_cluster_with</span></span>(<span>self, idx: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new cluster with the item index <code>idx</code>.
Removes <code>idx</code> from the previous cluster.</p>
<p>If you want a custom function to initialize the values and indicator variables
for the new cluster, pass in the functions as parameters. If not, it will
use the defualt that was used during initialization</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>This is the index of the item to make a new cluster with</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>This is the ID of the new cluster that was created</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_new_cluster_with(self, idx: int) -&gt; int:
    &#39;&#39;&#39;Create a new cluster with the item index `idx`.
    Removes `idx` from the previous cluster.

    If you want a custom function to initialize the values and indicator variables
    for the new cluster, pass in the functions as parameters. If not, it will
    use the defualt that was used during initialization

    Parameters
    ----------
    idx : int
        This is the index of the item to make a new cluster with

    Returns
    -------
    int
        This is the ID of the new cluster that was created
    &#39;&#39;&#39;
    old_cid = self.idx2cid[idx]
    self.clusters[old_cid].remove(idx)
    if self.clusters[old_cid].size == 0:
        # Delete the cluster
        self.clusters.pop(old_cid, None)
        self._cids_removed.append(old_cid)
    
    temp = _Cluster(members=[idx], parent=self, iden=self._CIDX)
    self._CIDX += 1
    self.clusters[temp.id] = temp
    self.idx2cid[idx] = temp.id
    self._cids_added.append(temp.id)
    self.order = list(self.clusters)
    self.n_clusters.value = len(self.clusters)

    self.cid2cidx = {}
    for cidx, cid in enumerate(self.order):
        self.cid2cidx[cid] = cidx

    # Signal to the cluster properties
    for prop in self.properties.signal_when_clusters_change:
        prop.clusters_changed(
            cids_added=self._cids_added,
            cids_removed=self._cids_removed)
    self._cids_added = []
    self._cids_removed = []

    return temp.id</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.merge_clusters"><code class="name flex">
<span>def <span class="ident">merge_clusters</span></span>(<span>self, cid1, cid2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_clusters(self, cid1, cid2):
    raise NotImplementedError(&#39;Not Implemented&#39;)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.move_item"><code class="name flex">
<span>def <span class="ident">move_item</span></span>(<span>self, idx: int, cid: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Move <code>idx</code> to cluster id <code>cid</code>. If <code>cid</code> does not exist, then we
will create a new cluster.</p>
<h2 id="paramters">Paramters</h2>
<p>idx : int
This is the index of the item to move clusters
cid : int
This is the Cluster ID to move <code>idx</code> to</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>This is the cluster ID it was moved to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_item(self, idx: int, cid: int) -&gt; int:
    &#39;&#39;&#39;Move `idx` to cluster id `cid`. If `cid` does not exist, then we 
    will create a new cluster.

    Paramters
    ---------
    idx : int
        This is the index of the item to move clusters
    cid : int
        This is the Cluster ID to move `idx` to

    Returns
    -------
    int
        This is the cluster ID it was moved to
    &#39;&#39;&#39;
    if cid not in self:
        return self.make_new_cluster_with(idx)

    # get the id of the cluster (could be an index)
    cid = self[cid].id

    curr_cid = self.idx2cid[idx]
    if cid == curr_cid:
        # Do nothing
        return cid
    
    self.clusters[curr_cid].remove(idx)
    old_cluster_deleted = False
    if self.clusters[curr_cid].size == 0:
        old_cluster_deleted = True
        self.clusters.pop(curr_cid, None)
        self._cids_removed.append(curr_cid)

    self.clusters[cid].add(idx)
    self.idx2cid[idx] = cid
    self.order = list(self.clusters)
    self.cid2cidx = {}
    for cidx, cid in enumerate(self.order):
        self.cid2cidx[cid] = cidx
    self.n_clusters.value = len(self)

    if old_cluster_deleted:
        # Signal `clusters_changed`
        for prop in self.properties.signal_when_clusters_change:
            prop.clusters_changed(
                cids_added=[],
                cids_removed=self._cids_removed)
    else:
        # Signal `assignments_changed`
        for prop in self.properties.signal_when_item_assignment_changes:
            prop.assignments_changed()

    self._cids_removed = []
    self._cids_added = []
    return cid</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.set_trace"><code class="name flex">
<span>def <span class="ident">set_trace</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the trace of the cocluster and n_clusters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_trace(self, *args, **kwargs):
    &#39;&#39;&#39;Set the trace of the cocluster and n_clusters
    &#39;&#39;&#39;
    self.coclusters.set_trace(*args, **kwargs)
    self.n_clusters.set_trace(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.split_cluster"><code class="name flex">
<span>def <span class="ident">split_cluster</span></span>(<span>self, cid, members1, members2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_cluster(self, cid, members1, members2):
    raise NotImplementedError(&#39;Not Implemented&#39;)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.toarray"><code class="name flex">
<span>def <span class="ident">toarray</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Converts clusters into array format:
Each index is the index of an element that is being clustered. The value
is the cluster index. This is the same format was the input parameter for
<code>__init__</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toarray(self) -&gt; np.ndarray:
    &#39;&#39;&#39;Converts clusters into array format:
    Each index is the index of an element that is being clustered. The value
    is the cluster index. This is the same format was the input parameter for 
    `__init__`.
    
    Returns
    -------
    np.ndarray
    &#39;&#39;&#39;
    ret = np.zeros(len(self.items),dtype=int)
    for cidx, cluster in enumerate(self):
        for idx in cluster.members:
            ret[idx] = cidx
    return ret</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.cluster.Clustering.tolistoflists"><code class="name flex">
<span>def <span class="ident">tolistoflists</span></span>(<span>self) ‑> Iterator[Iterator[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts clusters into array format:
clusters = [clus1, &hellip;, clusN],
clusters{i} = [idx1, &hellip;, idxM]
each clusters{i} is a list of indices that are in that cluster</p>
<p>This is the same format was the input parameter for <code>__init__</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>This is the array of values with the correct order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tolistoflists(self) -&gt; Iterator[Iterator[int]]:
    &#39;&#39;&#39;Converts clusters into array format:
    clusters = [clus1, ..., clusN],
        clusters{i} = [idx1, ..., idxM]
    each clusters{i} is a list of indices that are in that cluster

    This is the same format was the input parameter for `__init__`
    
    Returns
    -------
    list
        This is the array of values with the correct order 
    &#39;&#39;&#39;
    ret = []
    for cluster in self:
        ret.append(list(cluster.members))
    return ret</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.graph.Node.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.base.Traceable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdsine2.pylab" href="index.html">mdsine2.pylab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mdsine2.pylab.cluster.isclustering" href="#mdsine2.pylab.cluster.isclustering">isclustering</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.isclusterproperty" href="#mdsine2.pylab.cluster.isclusterproperty">isclusterproperty</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.isclustervalue" href="#mdsine2.pylab.cluster.isclustervalue">isclustervalue</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.toarray_from_cocluster" href="#mdsine2.pylab.cluster.toarray_from_cocluster">toarray_from_cocluster</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdsine2.pylab.cluster.ClusterProperty" href="#mdsine2.pylab.cluster.ClusterProperty">ClusterProperty</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.assignments_changed" href="#mdsine2.pylab.cluster.ClusterProperty.assignments_changed">assignments_changed</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.clusters_changed" href="#mdsine2.pylab.cluster.ClusterProperty.clusters_changed">clusters_changed</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.reset" href="#mdsine2.pylab.cluster.ClusterProperty.reset">reset</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.set_signal_when_clusters_change" href="#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_clusters_change">set_signal_when_clusters_change</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.set_signal_when_item_assignment_changes" href="#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_item_assignment_changes">set_signal_when_item_assignment_changes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.cluster.ClusterValue" href="#mdsine2.pylab.cluster.ClusterValue">ClusterValue</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_trace" href="#mdsine2.pylab.cluster.ClusterValue.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.cluster_array" href="#mdsine2.pylab.cluster.ClusterValue.cluster_array">cluster_array</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.item_array" href="#mdsine2.pylab.cluster.ClusterValue.item_array">item_array</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.remove_local_trace" href="#mdsine2.pylab.cluster.ClusterValue.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_trace" href="#mdsine2.pylab.cluster.ClusterValue.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_values_from_array" href="#mdsine2.pylab.cluster.ClusterValue.set_values_from_array">set_values_from_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.cluster.Clustering" href="#mdsine2.pylab.cluster.Clustering">Clustering</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.cluster.Clustering.add_trace" href="#mdsine2.pylab.cluster.Clustering.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.from_array" href="#mdsine2.pylab.cluster.Clustering.from_array">from_array</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.generate_coclusters" href="#mdsine2.pylab.cluster.Clustering.generate_coclusters">generate_coclusters</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.keys" href="#mdsine2.pylab.cluster.Clustering.keys">keys</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.make_new_cluster_with" href="#mdsine2.pylab.cluster.Clustering.make_new_cluster_with">make_new_cluster_with</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.merge_clusters" href="#mdsine2.pylab.cluster.Clustering.merge_clusters">merge_clusters</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.move_item" href="#mdsine2.pylab.cluster.Clustering.move_item">move_item</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.set_trace" href="#mdsine2.pylab.cluster.Clustering.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.split_cluster" href="#mdsine2.pylab.cluster.Clustering.split_cluster">split_cluster</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.toarray" href="#mdsine2.pylab.cluster.Clustering.toarray">toarray</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.Clustering.tolistoflists" href="#mdsine2.pylab.cluster.Clustering.tolistoflists">tolistoflists</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>