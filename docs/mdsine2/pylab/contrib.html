<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mdsine2.pylab.contrib API documentation</title>
<meta name="description" content="These are classes that should be apart of pylab but need to be built
from many different modules. To get dependency structure right, all of these
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdsine2.pylab.contrib</code></h1>
</header>
<section id="section-intro">
<p>These are classes that should be apart of pylab but need to be built
from many different modules. To get dependency structure right, all of these
extra, bigger classes are built in here. No other modules can
depend on contrib</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;These are classes that should be apart of pylab but need to be built
from many different modules. To get dependency structure right, all of these
extra, bigger classes are built in here. No other modules can
depend on contrib
&#39;&#39;&#39;
import numpy as np
import numpy.random as npr
import sys
import logging
import scipy.special

# Typing
from typing import TypeVar, Generic, Any, Union, Dict, Iterator, Tuple, \
    Callable

from .base import BasePerturbation, Traceable
from .base import Perturbations as PerturbationSet
from . import variables
from .cluster import isclustervalue, ClusterValue, isclustering, \
    ClusterProperty, Clustering
from .graph import Node
from . import util, base

# Constants
DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE = False
DEFAULT_SIGNAL_WHEN_ITEM_ASSIGNMENT_CHANGES = False
DEFAULT_MAGNITUDE_SUFFIX = &#39;_magnitude&#39;
DEFAULT_PROBABILITY_SUFFIX = &#39;_probability&#39;
DEFAULT_INDICATOR_SUFFIX = &#39;_indicator&#39;

def isclusterperturbation(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks whether the input is a subclass of ClusterPerturbation

    Parameters
    ----------
    x : any
        Input instance to check the type of ClusterPerturbation
    
    Returns
    -------
    bool
        True if `x` is of type ClusterPerturbation, else False
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, ClusterPerturbationEffect)

def isclusterperturbationindicator(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks whether the input is a subclass of ClusterPerturbationIndicator

    Parameters
    ----------
    x : any
        Input instance to check the type of ClusterPerturbationIndicator
    
    Returns
    -------
    bool
        True if `x` is of type ClusterPerturbationIndicator, else False
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, ClusterPerturbationIndicator)

def isinteractions(x: Any) -&gt; bool:
    &#39;&#39;&#39;Type check if `x` is a subclass of Interactions

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of Interactions
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, Interactions)

class Perturbation(BasePerturbation, variables.Variable):
    &#39;&#39;&#39;This is an implementation of a perturbation where the 
    values *DO NOT* depend on clusters.

    If you want to compute the bayes factors for each item, you can 
    calculate ~np.isnan for the trace. This will give an indicator 
    array that you can then use to calculate the bayes factor.

    Parameters
    ----------
    starts, ends : dict
        Start and end of the perturbation for each subject
    taxa : pylab.base.TaxaSet
        Set of taxon/otu objects
    magnitude : pylab.variables.Variable, int/float, array, Optional
        If a pylab.variables.Variable is passed in it will create one
        with the value indicated. Defualt value is None
    indicator : pylab.variables.Variable, array, Optional
        This is the indicator of the perturbation. Default value is False 
        for every taxon
    probability : pylab.variables.Variable, float, Optional
        This is the probability that the perturbation affects a taxon, e.g.
          probability = 0.7, there&#39;s a 70% chance that the perturbation afffects 
          each taxon
    kwargs : dict
        - Extra arguments for the Node class
    &#39;&#39;&#39;
    def __init__(self, taxa: base.TaxaSet, starts: Dict[str, float], ends: Dict[str, float], 
        magnitude: Union[variables.Variable, np.ndarray, int, float]=None, 
        indicator: Union[variables.Variable, np.ndarray]=None, 
        probability: Union[variables.Variable, float]=None, **kwargs):
        
        variables.Variable.__init__(self, **kwargs)
        if self.G.perturbations is None:
            self.G.perturbations = PerturbationSet()
        BasePerturbation.__init__(self, starts=starts, ends=ends, name=self.name)
        
        if not base.istaxaset(taxa):
            raise TypeError(&#39;`taxa` ({}) must be pylab.base.TaxaSet&#39;.format(type(taxa)))

        self.G.perturbations.append(self)
        self.taxa = taxa
        n_taxa = len(self.taxa)
        self.set_value_shape(shape=(n_taxa, )) # Set the shape of the internal array

        # Set magnitude
        if magnitude is None:
            magnitude = np.full(n_taxa, 0)
        if util.isnumeric(magnitude):
            magnitude = np.full(n_taxa, magnitude)
        if util.isarray(magnitude):
            if len(magnitude) != n_taxa:
                raise ValueError(&#39;`magnitue` ({}) must have length {}&#39;.format(
                    len(magnitude), n_taxa))
            magnitude = variables.Variable(
                G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX, 
                value=magnitude)
            magnitude.set_value_shape((n_taxa,))
        elif variables.isVariable(magnitude):
            if len(magnitude) != n_taxa:
                raise ValueError(&#39;`magnitue` ({}) must have length {}&#39;.format(magnitude, n_taxa))
        else:
            raise TypeError(&#39;`magnitude` ({}) type not recognized&#39;.format(type(magnitude)))
              
        # Set probability
        if not variables.isVariable(probability):
            if not util.isfloat(probability) and probability is not None:
                raise ValueError(&#39;`probability` ({}) must be a pylab.variables.Variable&#39; \
                    &#39;, a float, or None&#39;.format(type(probability)))
            if util.isfloat(probability):
                if probability &lt; 0 or probability &gt; 1:
                    raise ValueError(&#39;`probability` ({}) must be in [0,1]&#39;.format(
                        probability))
            probability = variables.Variable(value=probability, G=self.G, dtype=float,
                name=self.name+DEFAULT_PROBABILITY_SUFFIX)

        # Set indicator
        if indicator is None:
            indicator = np.full(n_taxa, False, dtype=bool)
        if util.isbool(indicator):
            indicator = np.full(n_taxa, indicator, dtype=bool)
        if util.isarray(indicator):
            if len(indicator) != n_taxa:
                raise ValueError(&#39;`indicator` ({}) must have length {}&#39;.format(
                    len(indicator), n_taxa))
            indicator = variables.Variable(
                G=self.G, dtype=bool, name=self.name+DEFAULT_INDICATOR_SUFFIX, 
                value=indicator)
            indicator.set_value_shape((n_taxa,))
        elif variables.isVariable(indicator):
            if len(indicator) != n_taxa:
                raise ValueError(&#39;`magnitue` ({}) must have length {}&#39;.format(indicator, n_taxa))
        else:
            raise TypeError(&#39;`indicator` ({}) type not recognized&#39;.format(type(indicator)))

        self.magnitude = magnitude # Variable
        self.indicator = indicator # Variable
        self.probability = probability # Variable

    def __str__(self) -&gt; str:
        s = BasePerturbation.__str__(self)
        s += &#39;\nMagnitude:\n&#39;
        for oidx in range(len(self.taxa)):
            s += &#39;\t{}: {}\n&#39;.format(oidx, self.magnitude.value[oidx])
        s += &#39;Indicator:\n&#39;
        for oidx in range(len(self.taxa)):
            s += &#39;\t{}: {}\n&#39;.format(oidx, self.indicator.value[oidx])
        s += &#39;Probability: {}&#39;.format(self.probability.value)
        return s

    def add_trace(self):
        &#39;&#39;&#39;Set the negative indicators as np.nan
        &#39;&#39;&#39;
        self.value = np.full(len(self.taxa), np.nan)
        ind = self.indicator.value
        self.value[ind] = self.magnitude.value[ind]
        variables.Variable.add_trace(self)

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def array(self, only_pos_ind: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Return the magnitudes with the indicatrs indexed out

        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        &#39;&#39;&#39;
        ind = self.indicator.value
        if only_pos_ind:
            val = self.magnitude.value[ind]
        else:
            val = np.zeros(len(self.taxa))
            val[ind] = self.magnitude.value[ind]
        return val


class ClusterPerturbationValue(ClusterValue):
    &#39;&#39;&#39;Extends `pylab.cluster.ClusterValue` object so it works for reset and cluster
    changed
    &#39;&#39;&#39;
    def reset(self):
        &#39;&#39;&#39;Reset all of the values
        &#39;&#39;&#39;
        self.value = {}
        for cid in self.clustering.order:
            self.value[cid] = 0

    def clusters_changed(self, cids_added: Iterator[int], cids_removed: Iterator[int]):
        &#39;&#39;&#39;Delete old clusters, sample from `prior` for the
        new clusters. We do not need to type check because it
        is self contained within pylab

        Parameters
        ----------
        cids_added (list(int))
            - These are a list of cluster ids to add
        cids_removed (list(int))
            - These are the cids that were removed
        &#39;&#39;&#39;
        for cid in cids_removed:
            self.value.pop(cid)
        for cid in cids_added:
            self.value[cid] = self.prior.sample()

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None


class ClusterPerturbationIndicator(ClusterValue):
    &#39;&#39;&#39;Extends the `pylab.cluster.ClusterValue` object so that it works for being a 
    cluster perturbation indicator
    
    Implements the `clusters_changed` function required by a ClusterProperty
    and provides a direct pointer to the probability object

    Parameters
    ----------
    probability : pl.variables.Variable
        This is the variable object that holds the probability for a positive indicator
    kwargs : dict
        These are additional arguments for ClusterValue
    &#39;&#39;&#39;
    def __init__(self, probability: variables.Variable, **kwargs):
        ClusterValue.__init__(self, dtype=bool, **kwargs)
        self.probability = probability

    def reset(self):
        &#39;&#39;&#39;Reset all of the values
        &#39;&#39;&#39;
        self.value = {}
        for cid in self.clustering.order:
            self.value[cid] = False

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def clusters_changed(self, cids_added: Iterator[int], cids_removed: Iterator[int]):
        &#39;&#39;&#39;Delete old clusters, sample from `probability` for the
        new clusters. We do not need to type check because it
        is self contained within pylab

        Parameters
        ----------
        cids_added (list(int))
            - These are a list of cluster ids to add
        cids_removed (list(int))
            - These are the cids that were removed
        &#39;&#39;&#39;
        for cid in cids_removed:
            self.value.pop(cid)
        for cid in cids_added:
            self.value[cid] = bool(npr.binomial(n=1, p=self.probability.value))

    def item_bool_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Creates a boolean array expanded so that each item has the same 
        value that the cluster that contains it has. This is the same as 
        calling ClusterValue.item_array
        Example
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; np.ndarray([True, False, True, False, True])
            ```

        Returns
        -------
        np.ndarray((n,), dtype=bool)
            A numpy bool array for each item
        &#39;&#39;&#39;
        return ClusterValue.item_array(self)

    def cluster_bool_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Creates a boolean array for each item in cluster order. This 
        is the same as calling ClusterValue.cluster_array()

        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; np.ndarray([True, False])
            ```
        
        Returns
        -------
        np.ndarray((n,), dtype=bool)
            A numpy bool array for each cluster
        &#39;&#39;&#39;
        return ClusterValue.cluster_array(self)

    def item_arg_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Creates an ordered index array of items that are positive.
        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; np.ndarray([0,2,4])
            ```

        Returns
        -------
        np.ndarray((n_c,), dtype=int)
            A numpy index array for each item
        &#39;&#39;&#39;
        val = []
        for cluster in self.clustering:
            if self.value[cluster.id]:
                val += list(cluster.members)
        return np.asarray(val, dtype=int)

    def cluster_arg_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Creates an ordered index array of clusters that are positive.
        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; np.ndarray([0])
            ```

        Returns
        -------
        np.ndarray((n_c,), dtype=int)
            A numpy index array for each cluster
        &#39;&#39;&#39;

        return np.asarray([idx for idx,cid in enumerate(self.clustering.order) \
            if self.value[cid]], dtype=int)

    def num_on_items(self) -&gt; int:
        &#39;&#39;&#39;These are the number of on items for this perturbation
        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; 3
            ```

        Returns
        -------
        int
            This is the number of postiive items
        &#39;&#39;&#39;
        try:
            cumm = 0
            for cluster in self.clustering:
                if self.value[cluster.id]:
                    cumm += cluster.size
            return int(cumm)
        except:
            logging.critical(&#39;Inner cluster ids:\n{}&#39;.format(list(self.value.keys())))
            logging.critical(&#39;Clustering cluster ids:\n{}&#39;.format(self.clustering.order))
            raise

    def num_on_clusters(self) -&gt; int:
        &#39;&#39;&#39;These are the number of on clusters for this perturbation
        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; 1
            ```

        Returns
        -------
        int
            This is the number of postiive clusters
        &#39;&#39;&#39;
        cumm = 0
        for cid in self.clustering.order:
            cumm += self.value[cid]
        return cumm

    def get_clusters_on(self) -&gt; Iterator[int]:
        &#39;&#39;&#39;Return the cluster IDs that have a positive indicator for this
        perturbation.

        Returns
        -------
        list(int)
        &#39;&#39;&#39;
        ret = [cid for cid in self.clustering.order if self.value[cid]]
        return ret

    def get_items_on(self) -&gt; Iterator[int]:
        &#39;&#39;&#39;Get the item indecies that have a positive indicator for this
        perturbation.

        Returns
        -------
        list(int)
        &#39;&#39;&#39;
        ret = []
        for cid in self.clustering.order:
            if self.value[cid]:
                ret += list(self.clustering.clusters[cid].members)
        return ret


class ClusterPerturbationEffect(BasePerturbation, variables.Variable):
    &#39;&#39;&#39;This is an basic implementation for a perturbation where the 
    values **DO** depend on clusters. We trace the values at the item level.
    Effectively the same as `pylab.contrib.Perturbation` but it si extended
    to deal with clusters.

    If you want to compute the bayes factors for each item, you can 
    calculate ~np.isnan for the trace. This will give an indicator 
    array that you can then use to calculate the bayes factor.
    
    Parameters
    ----------
    starts, ends : dict
        - Start and end of the perturbation
    clustering : pylab.cluster.Clustering
        - This is the clustering object it is being set with
    magnitude : pylab.variables.Variable, pylab.cluster.ClusterValue, int/float, array, Optional
        - If a pylab.variables.Variable is passed in it will create one
          with the value indicated. Defualt value is None
    indicator : pylab.cluster.ClusterValue, array, Optional
        - This is the indicator of the interaction (vector, an indicator
          for every cluster). Default value is False for every cluster
    probability : pylab.variables.Variable, float, Optional
        - This is the probability that the perturbation affects a cluster, e.g.
          probability = 0.7, there&#39;s a 70% chance that the perturbation afffects 
          each cluster
    kwargs : dict
        - Extra arguments for the Node class
    &#39;&#39;&#39;
    def __init__(self, clustering: Clustering, starts: Dict[str, float], 
        ends: Dict[str, float], magnitude: Union[variables.Variable, ClusterValue, np.ndarray]=None, 
        indicator: Union[variables.Variable, ClusterValue, np.ndarray]=None, 
        probability: Union[variables.Variable, float]=None, signal_when_clusters_change: bool=False,
        signal_when_item_assignment_changes: bool=False, **kwargs):

        if signal_when_clusters_change is None:
            signal_when_clusters_change = DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE
        if signal_when_item_assignment_changes is None:
            signal_when_item_assignment_changes = DEFAULT_SIGNAL_WHEN_ITEM_ASSIGNMENT_CHANGES
        if not isclustering(clustering):
            raise TypeError(&#39;`clustering` ({}) must be a pylab.cluster.Clustering object&#39;.format(
                type(clustering)))
        
        variables.Variable.__init__(self, **kwargs)
        if self.G.perturbations is None:
            self.G.perturbations = PerturbationSet()

        BasePerturbation.__init__(self, starts=starts, ends=ends, name=self.name)
        self.G.perturbations.append(self)
        self.clustering = clustering
        self.set_value_shape(shape=(len(self.clustering.items), ))
        if magnitude is not None:
            if util.isarray(magnitude):
                temp = ClusterPerturbationValue(clustering=clustering, 
                    G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
                    signal_when_clusters_change=signal_when_clusters_change,
                    signal_when_item_assignment_changes=signal_when_item_assignment_changes)
                temp.set_values_from_array(magnitude)
                magnitude=temp
            elif not isclustervalue(magnitude):
                raise TypeError(&#39;`magnitude` ({})&#39; \
                    &#39; must be an array or a pylab.cluster.ClusterValue&#39;.format(type(magnitude)))
        else:
            magnitude = ClusterPerturbationValue(clustering=clustering, 
                G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
                signal_when_clusters_change=signal_when_clusters_change,
                signal_when_item_assignment_changes=signal_when_item_assignment_changes)            

        if not variables.isVariable(probability):
            if not util.isfloat(probability) and probability is not None:
                raise ValueError(&#39;`probability` ({}) must be a pylab.variables.Variable&#39; \
                    &#39;, a float, or None&#39;.format(type(probability)))
            if util.isfloat(probability):
                if probability &lt; 0 or probability &gt; 1:
                    raise ValueError(&#39;`probability` ({}) must be in [0,1]&#39;.format(
                        probability))
            probability = variables.Variable(value=probability, G=self.G, dtype=float,
                name=self.name+DEFAULT_PROBABILITY_SUFFIX)
        if not isclustervalue(indicator):
            if not util.isarray(indicator) and indicator is not None:
                raise ValueError(&#39;`indicator` ({}) must be a pylab.cluster.ClusterValue,&#39; \
                    &#39; array, or None&#39;.format(type(indicator)))
            if util.isarray(indicator):
                if len(indicator) != len(self.clustering):
                    raise ValueError(&#39;If `indicator` ({}) is an array, it must have the &#39; \
                        &#39;same number of elements as number of clusters ({})&#39;.format(
                            len(indicator), len(self.clustering)))
            ind = ClusterPerturbationIndicator(
                G=self.G, 
                name=self.name+DEFAULT_INDICATOR_SUFFIX,
                clustering=clustering,
                probability=probability,
                signal_when_clusters_change=signal_when_clusters_change,
                signal_when_item_assignment_changes=signal_when_item_assignment_changes)
            if util.isarray(indicator):
                ind.set_values_from_array(indicator)
            else:
                for cid in ind.clustering.order:
                    ind.value[cid] = False
            indicator = ind

        self.magnitude = magnitude # ClusterPerturbationValue
        self.indicator = indicator # ClusterPerturbationIndicator
        self.probability = probability # variables.Variable

    def __str__(self) -&gt; str:
        s = BasePerturbation.__str__(self)
        s += &#39;\nMagnitude:\n&#39;
        for cid in self.clustering.order:
            s += &#39;\t{}: {}\n&#39;.format(cid, self.magnitude.value[cid])
        s += &#39;Indicator:\n&#39;
        for cid in self.clustering.order:
            s += &#39;\t{}: {}\n&#39;.format(cid, self.indicator.value[cid])
        s += &#39;Probability: {}&#39;.format(self.probability.value)
        return s

    def item_array(self, only_pos_ind: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Expands the condensed form into a variable for each item
        in the data.

        Example
            ```
            ** Cluster assignments **
            cluster1 = {0,2,4}
            cluster2 = {1,3}

            ** Cluster indicators for perturbation **
            value[cluster1] = True
            value[cluster2] = False

            magnitude.value = -0.5

            &gt;&gt;&gt; np.ndarray([-0.5, 0, -0.5, 0, -0.5])
            ```
        
        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        &#39;&#39;&#39;
        ind = self.indicator.item_bool_array()
        if only_pos_ind:
            val = self.magnitude.item_array()[ind]
        else:
            val = np.zeros(len(self.clustering.items))
            val[ind] = self.magnitude.item_array()[ind]
        return val

    def cluster_array(self, only_pos_ind: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Make an array for each cluster with the magnitude

        Example
            ```
            ** Cluster assignments **
            cluster1 = {0,2,4}
            cluster2 = {1,3}

            ** Cluster indicators for perturbation **
            value[cluster1] = True
            value[cluster2] = False

            magnitude.value = -0.5

            &gt;&gt;&gt; np.ndarray([-0.5, 0])
            ```
        
        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        &#39;&#39;&#39;
        ind = self.indicator.cluster_bool_array()
        if only_pos_ind:
            val = self.magnitude.cluster_array()[ind]
        else:
            val = np.zeros(len(self.clustering))
            val[ind] = self.magnitude.cluster_array()[ind]
        return val
    
    def add_trace(self):
        &#39;&#39;&#39;Set the negative indicators as np.nan
        &#39;&#39;&#39;
        self.value = np.full(len(self.clustering.items), np.nan)
        ind = self.indicator.item_arg_array()
        self.value[ind] = self.magnitude.item_array()[ind]
        variables.Variable.add_trace(self)

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def set_values_from_array(self, values: np.ndarray, use_indicators: bool=True):
        &#39;&#39;&#39;Sets the values from an array of the same order as the clusters.

        Paramters
        ---------
        values : array_like
            An array of the values
            Must be the same length as the number of clusters is `use_indicators` 
            is False. If `use_indicators` is True, then the length must correspond
            to how many positive indicators there are.
        use_indicators : bool
            If True, the values  only correspond to positive interactions. Else
            the values correspond to every cluster
        &#39;&#39;&#39;
        if not util.isarray(values):
            raise ValueError(&#39;`values` ({}) must be an array&#39;.format(type(values)))
        if not util.isbool(use_indicators):
            raise TypeError(&#39;`use_indicators` ({}) must be a bool&#39;.format(
                type(use_indicators)))
        if not use_indicators:
            # Checking is done within this function
            self.magnitude.set_values_from_array(values)
        else:
            if len(values) != self.indicator.num_on_clusters():
                raise ValueError(&#39;The length of the array ({}) does not correspond&#39; \
                    &#39; to how many on indicators there are ({})&#39;.format(
                        len(values), self.indicator.num_on_clusters()))
            i = 0
            for cid in self.clustering.order:
                if self.indicator.value[cid]:
                    self.magnitude.value[cid] = values[i]
                    i += 1


class Interactions(ClusterProperty, Node, Traceable):
    &#39;&#39;&#39;This is a basic class for interactions between clusters.

    This is a 2D dictionary. The first level of the dictionary indexes the target 
    cluster and the second level indexes the source cluster. You can make this 2 
    layer dictionary into a matrix or a vector with functions defined in this class. 
    The reason why the data is stored in a 2D dictionary is because the number of 
    clusters changes constantly, so inserting and deleting values in a dictionary is more
    efficient than using a matrix/pandas.DataFrame. Additionally, the order of the clusters
    are changing constantly. Having them as a 2D dictionary allows us to reference the 
    interactions in the same order as the clusters as they are defined in `clusters`.

    Tracing
    -------
    The interactions get traced on an item-item bases. In this class we assume there are no
    interactions within a cluster. If the indicator is False, we set the trace to np.nan.
    To get the indicators call `np.nan_to_num` on the trace. We do not trace the indicators 
    separately, but you can get the trace of the interactions by calling ~np.isnan(self.trace).

    Indicators
    ----------
    You can choose whether to use or not use indicators for the interactions. If you choose
    not to use the indicators, then we assume that every indicator is positive.

    Iterators
    ---------
    These interactions assume the following order during iterating:
        For target cluster in clusters:
            For source cluster in clusters:
                if they are the same cluster, skip
                else yield value[target][source]
    Clusters are ordered in the same way as clustering.

    Value and indicator initialization
    ----------------------------------
    The values and indicators for a new interaction that gets made need to be initialized to 
    a value so we use the parameters `value_initializer` and  `inidicator_initializer`. If they
    are not specified then we return `np.nan` During initialization of the inference these are 
    usually set to the priors of the variables.

    The initializer for the indicator is assumed to either return a `bool` or a float betwen 
    [0,1]. It will set it to true if the sampled value is &gt;= 0.5. There is no checking for 
    this though.

    Parameters
    ----------
    clustering : Clustering
        Clustering object
    use_indicators : bool
        If True, use indicators. If False do not use indicators (automatically sets all indicators)
        to True
    value_initializer : callable, None
        This is the function that initializes the value of the `value` attribute for an interaction. 
        During MCMC you could set this to the sample method of the prior. 
        Defaults always returning np.nan.
    indicator_initializer : callable, None
        This is the function that initializes the value of the `value` attribute for an interaction. 
        During MCMC you could set this to the sample method of the prior.         
        Defaults to always returning True
    &#39;&#39;&#39;
    def __init__(self, clustering: Clustering, use_indicators: bool, 
        value_initializer: Callable=None, indicator_initializer: Callable=None, 
        signal_when_clusters_change: bool=True, **kwargs):

        Node.__init__(self, **kwargs)
        ClusterProperty.__init__(self, clustering=clustering, 
            signal_when_clusters_change=signal_when_clusters_change, 
            signal_when_item_assignment_changes=False)

        if value_initializer is None:
            value_initializer = _always_return_nan
        if indicator_initializer is None:
            indicator_initializer = _always_return_nan
        if not np.all(util.itercheck([value_initializer, indicator_initializer], callable)):
            raise TypeError(&#39;`value_initializer` ({}) and `indicator_initializer` ({}) &#39; \
                &#39;must be callable&#39;.format(type(value_initializer), 
                type(indicator_initializer)))

        self.value_initializer = value_initializer # function (callable)
        self.indicator_initializer = indicator_initializer # function (callable)
        self._IIDX = 1001001 # Index of the interactions
        
        if not util.isbool(use_indicators):
            raise TypeError(&#39;`use_indicators` ({}) must be a bool&#39;.format(type(use_indicators)))
        self.use_indicators = use_indicators # bool
        if not self.use_indicators:
            self.indicator_initializer = _always_return_true

        order = self.clustering.order

        # dict of a dict mapping to _Interaction objects
        # (target cluster, source cluster) -&gt; interaction
        self.value = {}
        for tcid in order:
            self.value[tcid] = {}
            for scid in order:
                if tcid == scid:
                    continue
                self.value[tcid][scid] = _Interaction( 
                    source_cid=scid, target_cid=tcid,
                    value=self.value_initializer(),
                    indicator=self.indicator_initializer(),
                    iden=self._IIDX)
                self._IIDX += 1

        self._shape = (len(self.clustering.items), len(self.clustering.items))
        self.dtype = float

    def __getitem__(self, key: Any) -&gt; &#39;_Interaction&#39;:
        return self.value[key]

    def __setitem__(self, key, val):
        self.value[key] = val

    def __iter__(self) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Iterates over the interactions in order
        &#39;&#39;&#39;
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    yield temp[scid]

    def __str__(self) -&gt; str:
        s=&#39;&#39;
        for interaction in self:
            s += str(interaction) + &#39;\n&#39;
        return s
    
    @property
    def size(self) -&gt; int:
        &#39;&#39;&#39;Return how many interactions there are possible according to the number of clusters.
        THIS IS NOT HOW MANY POSITIVE INTERACTIONS THERE ARE - USE `num_pos_interactions`

        Returns
        -------
        int
        &#39;&#39;&#39;
        n_clusters = len(self.clustering)
        return n_clusters * (n_clusters - 1)

    def iter_valid(self) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Iterate only over the positive indicators
        &#39;&#39;&#39;
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    if temp[scid].indicator:
                        yield temp[scid]

    def iter_valid_pairs(self) -&gt; Tuple[int, int]:
        &#39;&#39;&#39;Iterate only over the positive indicators
        &#39;&#39;&#39;
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    if temp[scid].indicator:
                        yield tcid, scid

    def iter_to_target(self, cid: int, only_valid: bool=False) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Iterates over interactions to the target cluster from all
        source clusters in the order specified by clusters

        Paramters
        ---------
        cid : int
            This is the target cluster id we are iterating from
        only_valid : bool
            If True, only returns the interactions with a positive indicator
        &#39;&#39;&#39;
        order = self.clustering.order
        temp = self.value[cid] # For quicker pointer
        if only_valid:
            for scid in order:
                if scid != cid:
                    if temp[scid].indicator:
                        yield temp[scid]
        else:
            for scid in order:
                if scid != cid:
                    yield temp[scid]

    def iter_from_source(self, cid: int, only_valid: bool=False) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Iterates over interactions from the source cluster to all
        target clusters in the order specified by clusters

        Paramters
        ---------
        cid (int)
            This is the source cluster id
        only_valid : bool
            If True, only returns the interactions with a positive indicator
        &#39;&#39;&#39;
        order = self.clustering.order
        if only_valid:
            for tcid in order:
                if tcid != cid:
                    if self.value[tcid][cid].indicator:
                        yield self.value[tcid][cid]
        else:
            for tcid in order:
                if tcid != cid:
                    yield self.value[tcid][cid]

    def reset(self):
        &#39;&#39;&#39;Reset all of the interactions
        &#39;&#39;&#39;
        self.value = {}
        for tcid in self.clustering.order:
            self.value[tcid] = {}
            for scid in self.clustering.order:
                if tcid == scid:
                    continue
                self.value[tcid][scid] = _Interaction(
                    source_cid=scid, target_cid=tcid,
                    value=self.value_initializer(),
                    indicator=self.indicator_initializer()&gt;=.5, 
                    iden=self._IIDX)
                self._IIDX += 1

    def iloc(self, idx: int) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Get the interaction as a function of the index that it occurs at.
        Reverse indexing is allowed.

        Parameters
        ----------
        idx : int
            This is the index that the interaction occurs at

        Returns
        -------
        pylab.contrib._Interaction
        &#39;&#39;&#39;
        if not util.isint(idx):
            raise TypeError(&#39;`idx` ({}) must be an int&#39;.format(idx))
        if idx &gt;= self.size:
            raise ValueError(&#39;`idx` ({}) cannot be &gt;= the number of interactions ({})&#39;.format(
                idx, self.size))
        if idx &lt; 0:
            idx = self.size - idx
        tcidx = idx // (len(self.clustering) - 1)
        scidx = idx - tcidx * (len(self.clustering) - 1)
        if scidx &gt;= tcidx:
            scidx += 1
        return self.value[
            self.clustering.order[tcidx]][
            self.clustering.order[scidx]]

    def clusters_changed(self, cids_added: Iterator[int], cids_removed: Iterator[int]):
        &#39;&#39;&#39;Remove all of the interactions to and from the clusters
        in `cids_removed` and make interactions for the `cid_added`

        Parameters
        ----------
        cids_removed : list(int)
            IDs of the clusters removed
        cids_added : list(int)
            IDs of the clusters added
        &#39;&#39;&#39;
        # Remove interactions from clusters deleted
        if len(cids_removed) &gt; 0:
            for cid in cids_removed:
                self.value.pop(cid, None)
            for cid in self.value.keys():
                for cid_del in cids_removed:
                    self.value[cid].pop(cid_del, None)
        if len(cids_added) &gt; 0:
            for cid in cids_added:
                self._add_single_cluster(cid)
        
    def _add_single_cluster(self, cid: int):
        other_cids = self.value.keys()
        # Add the interaction from clusters already there and 
        # the new cluster
        for ocid in other_cids:
            self.value[ocid][cid] = _Interaction(
                source_cid=cid, target_cid=ocid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer() &gt;= 0.5,
                iden=self._IIDX)
            self._IIDX += 1
        self.value[cid] = {}
        for ocid in other_cids:
            self.value[cid][ocid] = _Interaction(
                source_cid=ocid, target_cid=cid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer() &gt;= 0.5,
                iden=self._IIDX)
            self._IIDX += 1
    
    def key_pairs(self, only_valid: bool=False) -&gt; Iterator[Tuple[int, int]]:
        &#39;&#39;&#39;Returns (target,source) cluster ids in order

        Parameters
        ----------
        only_valid : bool
            If True, it will only return the key pairs that have a positive indicator.
            Else it will return all of the interactions regardless of the indicator.

        Returns 
        -------
        list((int,int))
            Return a list of the (target, source) cluster IDs for each interaciton
            in order.
        &#39;&#39;&#39;
        order = self.clustering.order
        l = []
        for tcid in order:
            for scid in order:
                if tcid != scid:
                    if only_valid:
                        if self.value[tcid][scid].indicator:
                            l.append((tcid, scid))
                    else:
                        l.append((tcid,scid))
        return l

    def num_neg_indicators(self, target_cid: int=None) -&gt; int:
        &#39;&#39;&#39;Return the number of indicator variables that are 0

        If target_cid is not None, calculate them for only the interactions going into
        that cluster

        Paramters
        ---------
        target_cid : int, Optional
            If this is specified, get only the negative indicators going into the cluster 
            `target_cid`
        &#39;&#39;&#39;
        cumm = 0
        if target_cid is not None:
            for interaction in self.iter_to_target(target_cid):
                cumm += not interaction.indicator
        else:
            for interaction in self:
                cumm += not interaction.indicator
        return cumm

    def num_pos_indicators(self, target_cid: int=None) -&gt; int:
        &#39;&#39;&#39;Return the number of indicator variables that are 1

        If target_cid is not None, calculate them for only the interactions going into
        that cluster

        Paramters
        ---------
        target_cid : int, Optional
            If this is specified, get only the positive indicators going into the cluster 
            `target_cid`
        &#39;&#39;&#39;
        cumm = 0
        if target_cid is not None:
            for interaction in self.iter_to_target(target_cid):
                cumm += interaction.indicator
        else:
            for interaction in self:
                cumm += interaction.indicator
        return cumm

    def get_arg_indicators(self, target_cid: int=None, source_cid: int=None) -&gt; Iterator[int]:
        &#39;&#39;&#39;Get the positive indicators as indices, in order -&gt; same convention
        as `get_indicators`.

        If `target_cid` is specfied, it will get all of the positive indicator indicies 
        going to the target cluster `target_cid` in order. If `source_cid` is specified,
        then it will get all of the positive indicator indices going to the source cluster 
        `source_cid` in order. If both `target_cid` and `source_cid` are specified,
        it will return an empty array if the indicator is False or it will return
        an array of size 1 if the indicator is True.

        Parameters
        ----------
        target_cid, source_cid : int, None
            These are the target cluster ID and source cluster ID, respectively.
            If None then nothing is specified.

        Returns
        -------
        list(int)
            Returns a list of the interactions that are positive in order
        &#39;&#39;&#39;
        ret = []
        try:
            if target_cid is not None:
                n_clusters = len(self.clustering)
                tcidx = self.clustering.cid2cidx[target_cid]

                if source_cid is not None:
                    if self.value[target_cid][source_cid].indicator:
                        scidx = self.clustering.cid2cidx[source_cid]
                        if tcidx &lt; scidx:
                            scidx -= 1
                        iidx = tcidx * (n_clusters - 1) + scidx
                        ret.append(iidx)
                else:
                    base_idx = tcidx * (n_clusters - 1)
                    for offset, interaction in enumerate(self.iter_to_target(target_cid)):
                        if interaction.indicator:
                            ret.append(base_idx + offset)
            
            elif source_cid is not None:
                # We do not need to check if target_cid is not None because 
                # it would have been covered in the previous check
                scidx = self.clustering.cid2cidx[source_cid]
                for interaction in self.iter_from_source(source_cid):
                    if interaction.indicator:
                        tcidx = self.clustering.cid2cidx[interaction.target_cid]

                        iidx = tcidx * (n_clusters - 1) + scidx
                        if scidx &gt; tcidx:
                            iidx -= 1
                        ret.append(iidx)

            else:
                for idx, interaction in enumerate(self):
                    if interaction.indicator:
                        ret.append(idx)
            return ret
        except:
            # Check to see if it is a key error, else it is something weird
            if target_cid is not None or source_cid is not None:
                if not util.isint(target_cid) or not util.isint(source_cid):
                    raise TypeError(&#39;`Either `target_cid` ({}) or `source_cid` ({})&#39; \
                        &#39; must be an int&#39;.format(type(target_cid), type(source_cid)))
                elif target_cid == source_cid:
                    raise ValueError(&#39;`target_cid` ({}) and `source_cid` ({}) cannot&#39; \
                        &#39; be the same&#39;.format(target_cid, source_cid))
            raise

    def get_indicators(self, target_cid: int=None, source_cid: int=None,
        return_idxs: bool=False) -&gt; Iterator[bool]:
        &#39;&#39;&#39;Return a the indicator variables as a vector in the order specified
        by the clusters.

        if `target_cid` is specified then it will return all indicators going
        to that cluster. If `source_cid` is specified then it will return all
        indicators going from that cluster. If both are specifeid then it
        will return an array of size 1 of a bool

        Parameters
        ----------
        target_cid, source_cid : int, None
            These are the target cluster ID and source cluster ID, respectively.
            If None then nothing is specified.
        return_idxs : bool
            If True, we return the index of the positive indicators. If False we 
            return an array of the indicator flags for every interaction. Nothing
            is done if both `target_cid` and `source_cid` are specified

        Returns
        -------
        np.ndarray(n, dtype=bool)
            Returns a bool vector of the indicators in roder
        &#39;&#39;&#39;
        if target_cid is not None or source_cid is not None and return_idxs:
            mapping = {}
            order = self.clustering.order
            i = 0
            for tcid in order:
                for scid in order:
                    if tcid == scid:
                        continue
                    mapping[(tcid, scid)] = i
                    i += 1
            
        try:
            if target_cid is not None:
                if source_cid is not None:
                    ret = np.asarray([self.value[target_cid][source_cid].indicator])
                else:
                    if return_idxs:
                        ret = []
                    else:
                        l = len(self.clustering) - 1
                        ret = np.zeros(l, dtype=bool)
                    for iidx, interaction in enumerate(self.iter_to_target(target_cid)):
                        if interaction.indicator:
                            if return_idxs:
                                ret.append(mapping[(target_cid, interaction.source_cid)])
                            else:
                                ret[iidx] = True
            elif source_cid is not None:
                # We do not need to check if target_cid is not None because 
                # it would have been covered in the previous check
                if return_idxs:
                    ret = []
                else:
                    l = len(self.clustering) - 1
                    ret = np.zeros(l, dtype=bool)
                for iidx, interaction in enumerate(self.iter_from_source(source_cid)):
                    if interaction.indicator:
                        if return_idxs:
                            ret.append(mapping[(interaction.target_cid, source_cid)])
                        else:
                            ret[iidx] = True

            else:
                if return_idxs:
                    ret = []
                else:
                    ret = np.zeros(self.size, dtype=bool)
                for idx, interaction in enumerate(self):
                    if interaction.indicator:
                        if return_idxs:
                            ret.append(idx)
                        else:
                            ret[idx] = True
                return ret
            if return_idxs:
                ret = np.asarray(ret, dtpye=int)
            return ret

        except:
            # Check to see if it is a key error, else it is something weird
            if target_cid is not None or source_cid is not None:
                if not util.isint(target_cid) or not util.isint(source_cid):
                    raise TypeError(&#39;`Either `target_cid` ({}) or `source_cid` ({})&#39; \
                        &#39; must be an int&#39;.format(type(target_cid), type(source_cid)))
                elif target_cid == source_cid:
                    raise ValueError(&#39;`target_cid` ({}) and `source_cid` ({}) cannot&#39; \
                        &#39; be the same&#39;.format(target_cid, source_cid))
            raise

    def set_indicators(self, arr: np.ndarray):
        &#39;&#39;&#39;Sets the values of the indicators of the interactions from a vector.

        If `include_self_interactions` is True, assumes that `arr` contains the
        values for the self interactions. If False, assume that the indices are
        skipped.

        Paramters
        ---------
        arr : np.ndarray(n, dtpye=bool)
            These are the indicator values to set, in order
        &#39;&#39;&#39;
        if len(arr) != self.size:
            raise ValueError(&#39;The number of elements in `arr` ({}) is not the &#39; \
                &#39;same as the number of interactions ({})&#39;.format(len(arr), self.size))
        for idx, interaction in enumerate(self):
            interaction.indicator = arr[idx]
            if interaction.indicator == 0:
                interaction.value = 0

    def set_values(self, arr: np.ndarray, use_indicators: bool=True):
        &#39;&#39;&#39;Sets the values of the interactions from a vector.

        If `use_indicators` is True, assumes that the values in the vector only contain
        values for interactions where the indicator variable is positive and the
        rest are skipped. If False, assumes the vector has values for where the
        indicator variables are positive and negative (all).

        Paramters
        ---------
        arr : np.ndarray(n, dtpye=float)
            These are the interaction values to set, in order
        use_indicators : bool, Optional
            If True, we only set the interactions with a positive indicator. Else we set every
            single interaction
        &#39;&#39;&#39;
        if not use_indicators:
            if len(arr) != self.size:
                raise ValueError(&#39;The number of elements in `arr` ({}) is not the &#39; \
                    &#39;same as the number of interactions ({})&#39;.format(len(arr), self.size))
            for idx, interaction in enumerate(self):
                interaction.value = arr[idx]
        else:
            # Dont check because it is too computationally intensive
            idx = 0
            for interaction in self:
                if not interaction.indicator:
                    continue
                interaction.value = arr[idx]
                idx += 1

    def get_values(self, use_indicators: bool=True) -&gt; np.ndarray:
        &#39;&#39;&#39;Makes a vector of the interaction variables in the order of the
        clustering

        if use_indicators is True, it skips over the indices that have a negative
        indicator variable. if it is True, it goes over everthing

         Paramters
        ---------
        use_indicators : bool, Optional
            If True, we only return the interactions with a positive indicator. Else we get every
            single interaction

        Returns
        -------
        np.ndarray(n, dtype=float)
            Array of the interaction values, in order
        &#39;&#39;&#39;
        ret = np.zeros(self.size)
        idx = 0
        if use_indicators:
            for interaction in self.iter_valid():
                ret[idx] = interaction.value
                idx += 1
        else:
            for interaction in self:
                ret[idx] = interaction.value
                idx += 1
        # Trim if necessary
        return ret[:idx]

    def get_value_matrix(self, set_neg_indicators_to_nan: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Get the interaction matrix at the clustert level (item-item). 
        The ordering of the clusters is the same as it is in clustering

        If `set_neg_indicators_to_nan` is True, interactions that have a negative
        indicator are set to np.nan. Else, they are set to 0.

        Parameters
        ----------
        set_neg_indicators_to_nan : bool
            If True, it will set the negative interaction indicator values to 
            np.nan. Else, it will set them to 0.

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the item-item interaction value matrix
        &#39;&#39;&#39;
        n_clusters = len(self.clustering)
        if set_neg_indicators_to_nan:
            fill = np.nan
        else:
            fill = 0
        ret = np.full(shape=(n_clusters, n_clusters), fill_value=fill, dtype=float)
        for interaction in self:
            if not interaction.indicator:
                continue
            tcidx = self.clustering.cid2cidx[interaction.target_cid]
            scidx = self.clustering.cid2cidx[interaction.source_cid]
            ret[tcidx, scidx] = interaction.value
        return ret

    def get_datalevel_value_matrix(self, set_neg_indicators_to_nan: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Get the interaction matrix at the data level (item-item), not
        at the cluster level. The ordering of the items is the same as 
        it is in the items in clustering (self.clustering.times).

        If `set_neg_indicators_to_nan` is True, interactions that have a negative
        indicator are set to np.nan. Else, they are set to 0.

        Parameters
        ----------
        set_neg_indicators_to_nan : bool
            If True, it will set the negative interaction indicator values to 
            np.nan. Else, it will set them to 0.

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the item-item interaction value matrix
        &#39;&#39;&#39;
        n_items = len(self.clustering.items)
        if set_neg_indicators_to_nan:
            fill = np.nan
        else:
            fill = 0
        ret = np.full(shape=(n_items, n_items), fill_value=fill, dtype=float)
        for interaction in self:
            if not interaction.indicator:
                continue
            val = interaction.value
            for tidx in self.clustering.clusters[interaction.target_cid].members:
                for sidx in self.clustering.clusters[interaction.source_cid].members:
                    ret[tidx, sidx] = val
        return ret
    
    def get_datalevel_indicator_matrix(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Get the item-item indicator matrix.

        The ordering of the items are the same as the order in
        self.clusters.items.ids.order

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the item-item interaction value matrix
        &#39;&#39;&#39;
        n_items = len(self.clustering.items)
        ret = np.zeros(shape=(n_items, n_items), dtype=bool)
        for interaction in self:
            if not interaction.indicator:
                continue
            for tidx in self.clustering.clusters[interaction.target_cid].members:
                for sidx in self.clustering.clusters[interaction.source_cid].members:
                    ret[tidx, sidx] = True
        return ret

    def generate_in_out_degree_posthoc(self, section: str=&#39;posterior&#39;) -&gt; Dict[str, np.ndarray]:
        &#39;&#39;&#39;Returns a dictionary of arrays
        &#34;in&#34;
            For each index in the array, corresponding to the index of the items, returns
            the number of incoming interactions for each iteration of the item
        &#34;out&#34;
            For each index in the array, corresponding to the index of the items, returns
            the number of outgoing interactions for each iteration of the item

        Parameters
        ----------
        section : str
            Which section of the inference you want to choose. 
            Options:
                &#39;posterior&#39;
                    Only look at the posterior
                &#39;burnin&#39;
                    Returns the samples that were in the burnin
                &#39;entire&#39;
                    Returns all the samples
        &#39;&#39;&#39;
        trace = self.get_trace_from_disk(section=section)
        trace = ~np.isnan(trace)
        return {&#39;in&#39;: np.sum(trace, axis=2), &#39;out&#39;:np.sum(trace, axis=1)}

    def set_trace(self):
        &#39;&#39;&#39;Initialize the trace arrays for the variable in the Tracer object. 

        It will initialize a buffer the size of the checkpoint size in Tracer
        &#39;&#39;&#39;
        tracer = self.G.tracer
        tracer.set_trace(self.name, shape=self._shape, dtype=self.dtype)

        self.ckpt_iter = 0
        self.sample_iter = 0
        shape = (tracer.checkpoint, ) + self._shape
        self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def add_trace(self):
        &#39;&#39;&#39;Adds the current value to the trace. If the buffer is full
        it will end it to disk
        &#39;&#39;&#39;
        self.trace[self.ckpt_iter] = self.get_datalevel_value_matrix(set_neg_indicators_to_nan=True)
        self.ckpt_iter += 1
        self.sample_iter += 1
        if self.ckpt_iter == len(self.trace):
            # We have gotten the largest we can in the local buffer, write to disk
            self.G.tracer.write_to_disk(name=self.name)
            shape = (self.G.tracer.checkpoint, ) + self._shape
            self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)
            self.ckpt_iter = 0

    def get_adjacent(self, cid: int, incoming: bool, outgoing: bool, 
        use_indicators: bool=True) -&gt; Iterator[int]:
        &#39;&#39;&#39;Get all of the cluster IDs that have a positive interaction going into
        or from the cluster `cid`.

        Parameters
        ----------
        cid : int
            This is the Cluster ID you want to get the adjacent clusters of
        incoming : bool 
            Get the cids of the incoming edges
        outgoing : bool
            Get the cids of the outgoing edges
        use_indicators : bool
            If this is True then if the indicator is False then we do not include.
            If this is False then we always include the interaction

        Returns
        -------
        list
            List of cids
        &#39;&#39;&#39;
        if cid not in self.clustering.order:
            raise ValueError(&#39;`cid` ({}) not found&#39;.format(cid))
        cids = []
        if incoming:
            for interaction in self.iter_from_source(cid):
                if interaction.indicator or not use_indicators:
                    cids.append(interaction.target_cid)
        if outgoing:
            for interaction in self.iter_to_target(cid):
                if interaction.indicator or not use_indicators:
                    cids.append(interaction.source_cid)
        return cids
        

class _Interaction:
    &#39;&#39;&#39;Defines an interaction from cluster `source` to cluster `target`.

    Parameters
    ----------
    source_cid : int
        Unique id of the source cluster
    target_cid : int
        Unique id of the target cluster
    value : numeric
        The value of the interaction
    indicator : bool
        Indicator variable of the interaction
    iden : int
        Unique identifier of this interaction object
    &#39;&#39;&#39;
    def __init__(self, source_cid: int, target_cid: int, value: Union[int, float], 
        indicator: bool, iden: int):
        self.source_cid = source_cid
        self.target_cid = target_cid
        self.value = value
        self.indicator = indicator
        self.id = iden

    def __str__(self) -&gt; str:
        return &#39;Interaction {}\n&#39; \
            &#39;\tTarget cluster: {}\n&#39; \
            &#39;\tSource cluster: {}\n&#39; \
            &#39;\tValue: {}\n&#39; \
            &#39;\tIndicator: {}\n&#39;.format(
                self.id,
                self.target_cid,
                self.source_cid,
                self.value,
                self.indicator)


def _always_return_true(*args, **kwargs) -&gt; bool:
    return True

def _always_return_nan(*args, **kwargs) -&gt; float:
    return np.nan</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mdsine2.pylab.contrib.isclusterperturbation"><code class="name flex">
<span>def <span class="ident">isclusterperturbation</span></span>(<span>x:Â Any) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the input is a subclass of ClusterPerturbation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Input instance to check the type of ClusterPerturbation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is of type ClusterPerturbation, else False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isclusterperturbation(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks whether the input is a subclass of ClusterPerturbation

    Parameters
    ----------
    x : any
        Input instance to check the type of ClusterPerturbation
    
    Returns
    -------
    bool
        True if `x` is of type ClusterPerturbation, else False
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, ClusterPerturbationEffect)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.isclusterperturbationindicator"><code class="name flex">
<span>def <span class="ident">isclusterperturbationindicator</span></span>(<span>x:Â Any) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the input is a subclass of ClusterPerturbationIndicator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Input instance to check the type of ClusterPerturbationIndicator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is of type ClusterPerturbationIndicator, else False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isclusterperturbationindicator(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks whether the input is a subclass of ClusterPerturbationIndicator

    Parameters
    ----------
    x : any
        Input instance to check the type of ClusterPerturbationIndicator
    
    Returns
    -------
    bool
        True if `x` is of type ClusterPerturbationIndicator, else False
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, ClusterPerturbationIndicator)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.isinteractions"><code class="name flex">
<span>def <span class="ident">isinteractions</span></span>(<span>x:Â Any) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Type check if <code>x</code> is a subclass of Interactions</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Returns True if <code>x</code> is a subclass of Interactions</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is the correct subtype</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isinteractions(x: Any) -&gt; bool:
    &#39;&#39;&#39;Type check if `x` is a subclass of Interactions

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of Interactions
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, Interactions)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationEffect"><code class="flex name class">
<span>class <span class="ident">ClusterPerturbationEffect</span></span>
<span>(</span><span>clustering:Â <a title="mdsine2.pylab.cluster.Clustering" href="cluster.html#mdsine2.pylab.cluster.Clustering">Clustering</a>, starts:Â Dict[str,Â float], ends:Â Dict[str,Â float], magnitude:Â Union[<a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a>,Â <a title="mdsine2.pylab.cluster.ClusterValue" href="cluster.html#mdsine2.pylab.cluster.ClusterValue">ClusterValue</a>,Â numpy.ndarray]Â =Â None, indicator:Â Union[<a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a>,Â <a title="mdsine2.pylab.cluster.ClusterValue" href="cluster.html#mdsine2.pylab.cluster.ClusterValue">ClusterValue</a>,Â numpy.ndarray]Â =Â None, probability:Â Union[<a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a>,Â float]Â =Â None, signal_when_clusters_change:Â boolÂ =Â False, signal_when_item_assignment_changes:Â boolÂ =Â False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an basic implementation for a perturbation where the
values <strong>DO</strong> depend on clusters. We trace the values at the item level.
Effectively the same as <code>pylab.contrib.Perturbation</code> but it si extended
to deal with clusters.</p>
<p>If you want to compute the bayes factors for each item, you can
calculate ~np.isnan for the trace. This will give an indicator
array that you can then use to calculate the bayes factor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>starts</code></strong>, <strong><code>ends</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<ul>
<li>Start and end of the perturbation</li>
</ul>
</dd>
<dt><strong><code>clustering</code></strong> :&ensp;<code>pylab.cluster.Clustering</code></dt>
<dd>
<ul>
<li>This is the clustering object it is being set with</li>
</ul>
</dd>
<dt><strong><code>magnitude</code></strong> :&ensp;<code>pylab.variables.Variable, pylab.cluster.ClusterValue, int/float, array, Optional</code></dt>
<dd>
<ul>
<li>If a pylab.variables.Variable is passed in it will create one
with the value indicated. Defualt value is None</li>
</ul>
</dd>
<dt><strong><code>indicator</code></strong> :&ensp;<code>pylab.cluster.ClusterValue, array, Optional</code></dt>
<dd>
<ul>
<li>This is the indicator of the interaction (vector, an indicator
for every cluster). Default value is False for every cluster</li>
</ul>
</dd>
<dt><strong><code>probability</code></strong> :&ensp;<code>pylab.variables.Variable, float, Optional</code></dt>
<dd>
<ul>
<li>This is the probability that the perturbation affects a cluster, e.g.
probability = 0.7, there's a 70% chance that the perturbation afffects
each cluster</li>
</ul>
</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<ul>
<li>Extra arguments for the Node class</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClusterPerturbationEffect(BasePerturbation, variables.Variable):
    &#39;&#39;&#39;This is an basic implementation for a perturbation where the 
    values **DO** depend on clusters. We trace the values at the item level.
    Effectively the same as `pylab.contrib.Perturbation` but it si extended
    to deal with clusters.

    If you want to compute the bayes factors for each item, you can 
    calculate ~np.isnan for the trace. This will give an indicator 
    array that you can then use to calculate the bayes factor.
    
    Parameters
    ----------
    starts, ends : dict
        - Start and end of the perturbation
    clustering : pylab.cluster.Clustering
        - This is the clustering object it is being set with
    magnitude : pylab.variables.Variable, pylab.cluster.ClusterValue, int/float, array, Optional
        - If a pylab.variables.Variable is passed in it will create one
          with the value indicated. Defualt value is None
    indicator : pylab.cluster.ClusterValue, array, Optional
        - This is the indicator of the interaction (vector, an indicator
          for every cluster). Default value is False for every cluster
    probability : pylab.variables.Variable, float, Optional
        - This is the probability that the perturbation affects a cluster, e.g.
          probability = 0.7, there&#39;s a 70% chance that the perturbation afffects 
          each cluster
    kwargs : dict
        - Extra arguments for the Node class
    &#39;&#39;&#39;
    def __init__(self, clustering: Clustering, starts: Dict[str, float], 
        ends: Dict[str, float], magnitude: Union[variables.Variable, ClusterValue, np.ndarray]=None, 
        indicator: Union[variables.Variable, ClusterValue, np.ndarray]=None, 
        probability: Union[variables.Variable, float]=None, signal_when_clusters_change: bool=False,
        signal_when_item_assignment_changes: bool=False, **kwargs):

        if signal_when_clusters_change is None:
            signal_when_clusters_change = DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE
        if signal_when_item_assignment_changes is None:
            signal_when_item_assignment_changes = DEFAULT_SIGNAL_WHEN_ITEM_ASSIGNMENT_CHANGES
        if not isclustering(clustering):
            raise TypeError(&#39;`clustering` ({}) must be a pylab.cluster.Clustering object&#39;.format(
                type(clustering)))
        
        variables.Variable.__init__(self, **kwargs)
        if self.G.perturbations is None:
            self.G.perturbations = PerturbationSet()

        BasePerturbation.__init__(self, starts=starts, ends=ends, name=self.name)
        self.G.perturbations.append(self)
        self.clustering = clustering
        self.set_value_shape(shape=(len(self.clustering.items), ))
        if magnitude is not None:
            if util.isarray(magnitude):
                temp = ClusterPerturbationValue(clustering=clustering, 
                    G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
                    signal_when_clusters_change=signal_when_clusters_change,
                    signal_when_item_assignment_changes=signal_when_item_assignment_changes)
                temp.set_values_from_array(magnitude)
                magnitude=temp
            elif not isclustervalue(magnitude):
                raise TypeError(&#39;`magnitude` ({})&#39; \
                    &#39; must be an array or a pylab.cluster.ClusterValue&#39;.format(type(magnitude)))
        else:
            magnitude = ClusterPerturbationValue(clustering=clustering, 
                G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
                signal_when_clusters_change=signal_when_clusters_change,
                signal_when_item_assignment_changes=signal_when_item_assignment_changes)            

        if not variables.isVariable(probability):
            if not util.isfloat(probability) and probability is not None:
                raise ValueError(&#39;`probability` ({}) must be a pylab.variables.Variable&#39; \
                    &#39;, a float, or None&#39;.format(type(probability)))
            if util.isfloat(probability):
                if probability &lt; 0 or probability &gt; 1:
                    raise ValueError(&#39;`probability` ({}) must be in [0,1]&#39;.format(
                        probability))
            probability = variables.Variable(value=probability, G=self.G, dtype=float,
                name=self.name+DEFAULT_PROBABILITY_SUFFIX)
        if not isclustervalue(indicator):
            if not util.isarray(indicator) and indicator is not None:
                raise ValueError(&#39;`indicator` ({}) must be a pylab.cluster.ClusterValue,&#39; \
                    &#39; array, or None&#39;.format(type(indicator)))
            if util.isarray(indicator):
                if len(indicator) != len(self.clustering):
                    raise ValueError(&#39;If `indicator` ({}) is an array, it must have the &#39; \
                        &#39;same number of elements as number of clusters ({})&#39;.format(
                            len(indicator), len(self.clustering)))
            ind = ClusterPerturbationIndicator(
                G=self.G, 
                name=self.name+DEFAULT_INDICATOR_SUFFIX,
                clustering=clustering,
                probability=probability,
                signal_when_clusters_change=signal_when_clusters_change,
                signal_when_item_assignment_changes=signal_when_item_assignment_changes)
            if util.isarray(indicator):
                ind.set_values_from_array(indicator)
            else:
                for cid in ind.clustering.order:
                    ind.value[cid] = False
            indicator = ind

        self.magnitude = magnitude # ClusterPerturbationValue
        self.indicator = indicator # ClusterPerturbationIndicator
        self.probability = probability # variables.Variable

    def __str__(self) -&gt; str:
        s = BasePerturbation.__str__(self)
        s += &#39;\nMagnitude:\n&#39;
        for cid in self.clustering.order:
            s += &#39;\t{}: {}\n&#39;.format(cid, self.magnitude.value[cid])
        s += &#39;Indicator:\n&#39;
        for cid in self.clustering.order:
            s += &#39;\t{}: {}\n&#39;.format(cid, self.indicator.value[cid])
        s += &#39;Probability: {}&#39;.format(self.probability.value)
        return s

    def item_array(self, only_pos_ind: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Expands the condensed form into a variable for each item
        in the data.

        Example
            ```
            ** Cluster assignments **
            cluster1 = {0,2,4}
            cluster2 = {1,3}

            ** Cluster indicators for perturbation **
            value[cluster1] = True
            value[cluster2] = False

            magnitude.value = -0.5

            &gt;&gt;&gt; np.ndarray([-0.5, 0, -0.5, 0, -0.5])
            ```
        
        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        &#39;&#39;&#39;
        ind = self.indicator.item_bool_array()
        if only_pos_ind:
            val = self.magnitude.item_array()[ind]
        else:
            val = np.zeros(len(self.clustering.items))
            val[ind] = self.magnitude.item_array()[ind]
        return val

    def cluster_array(self, only_pos_ind: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Make an array for each cluster with the magnitude

        Example
            ```
            ** Cluster assignments **
            cluster1 = {0,2,4}
            cluster2 = {1,3}

            ** Cluster indicators for perturbation **
            value[cluster1] = True
            value[cluster2] = False

            magnitude.value = -0.5

            &gt;&gt;&gt; np.ndarray([-0.5, 0])
            ```
        
        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        &#39;&#39;&#39;
        ind = self.indicator.cluster_bool_array()
        if only_pos_ind:
            val = self.magnitude.cluster_array()[ind]
        else:
            val = np.zeros(len(self.clustering))
            val[ind] = self.magnitude.cluster_array()[ind]
        return val
    
    def add_trace(self):
        &#39;&#39;&#39;Set the negative indicators as np.nan
        &#39;&#39;&#39;
        self.value = np.full(len(self.clustering.items), np.nan)
        ind = self.indicator.item_arg_array()
        self.value[ind] = self.magnitude.item_array()[ind]
        variables.Variable.add_trace(self)

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def set_values_from_array(self, values: np.ndarray, use_indicators: bool=True):
        &#39;&#39;&#39;Sets the values from an array of the same order as the clusters.

        Paramters
        ---------
        values : array_like
            An array of the values
            Must be the same length as the number of clusters is `use_indicators` 
            is False. If `use_indicators` is True, then the length must correspond
            to how many positive indicators there are.
        use_indicators : bool
            If True, the values  only correspond to positive interactions. Else
            the values correspond to every cluster
        &#39;&#39;&#39;
        if not util.isarray(values):
            raise ValueError(&#39;`values` ({}) must be an array&#39;.format(type(values)))
        if not util.isbool(use_indicators):
            raise TypeError(&#39;`use_indicators` ({}) must be a bool&#39;.format(
                type(use_indicators)))
        if not use_indicators:
            # Checking is done within this function
            self.magnitude.set_values_from_array(values)
        else:
            if len(values) != self.indicator.num_on_clusters():
                raise ValueError(&#39;The length of the array ({}) does not correspond&#39; \
                    &#39; to how many on indicators there are ({})&#39;.format(
                        len(values), self.indicator.num_on_clusters()))
            i = 0
            for cid in self.clustering.order:
                if self.indicator.value[cid]:
                    self.magnitude.value[cid] = values[i]
                    i += 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.base.BasePerturbation" href="base.html#mdsine2.pylab.base.BasePerturbation">BasePerturbation</a></li>
<li><a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationEffect.add_trace"><code class="name flex">
<span>def <span class="ident">add_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the negative indicators as np.nan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_trace(self):
    &#39;&#39;&#39;Set the negative indicators as np.nan
    &#39;&#39;&#39;
    self.value = np.full(len(self.clustering.items), np.nan)
    ind = self.indicator.item_arg_array()
    self.value[ind] = self.magnitude.item_array()[ind]
    variables.Variable.add_trace(self)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationEffect.cluster_array"><code class="name flex">
<span>def <span class="ident">cluster_array</span></span>(<span>self, only_pos_ind:Â boolÂ =Â False) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Make an array for each cluster with the magnitude</p>
<p>Example
```
<strong> Cluster assignments </strong>
cluster1 = {0,2,4}
cluster2 = {1,3}</p>
<pre><code>** Cluster indicators for perturbation **
value[cluster1] = True
value[cluster2] = False

magnitude.value = -0.5

&gt;&gt;&gt; np.ndarray([-0.5, 0])
```
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>only_pos_ind</code></strong> :&ensp;<code>bool</code></dt>
<dd>If this is True, then it will return only for when the indicator is positive</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n_c,), dtype=float)</code></dt>
<dd>Array of the cluster perturbation values for each cluster</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_array(self, only_pos_ind: bool=False) -&gt; np.ndarray:
    &#39;&#39;&#39;Make an array for each cluster with the magnitude

    Example
        ```
        ** Cluster assignments **
        cluster1 = {0,2,4}
        cluster2 = {1,3}

        ** Cluster indicators for perturbation **
        value[cluster1] = True
        value[cluster2] = False

        magnitude.value = -0.5

        &gt;&gt;&gt; np.ndarray([-0.5, 0])
        ```
    
    Parameters
    ----------
    only_pos_ind : bool
        If this is True, then it will return only for when the indicator is positive

    Returns
    -------
    np.ndarray((n_c,), dtype=float)
        Array of the cluster perturbation values for each cluster
    &#39;&#39;&#39;
    ind = self.indicator.cluster_bool_array()
    if only_pos_ind:
        val = self.magnitude.cluster_array()[ind]
    else:
        val = np.zeros(len(self.clustering))
        val[ind] = self.magnitude.cluster_array()[ind]
    return val</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationEffect.item_array"><code class="name flex">
<span>def <span class="ident">item_array</span></span>(<span>self, only_pos_ind:Â boolÂ =Â False) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Expands the condensed form into a variable for each item
in the data.</p>
<p>Example
```
<strong> Cluster assignments </strong>
cluster1 = {0,2,4}
cluster2 = {1,3}</p>
<pre><code>** Cluster indicators for perturbation **
value[cluster1] = True
value[cluster2] = False

magnitude.value = -0.5

&gt;&gt;&gt; np.ndarray([-0.5, 0, -0.5, 0, -0.5])
```
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>only_pos_ind</code></strong> :&ensp;<code>bool</code></dt>
<dd>If this is True, then it will return only for when the indicator is positive</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n_c,), dtype=float)</code></dt>
<dd>Array of the cluster perturbation values for each cluster</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item_array(self, only_pos_ind: bool=False) -&gt; np.ndarray:
    &#39;&#39;&#39;Expands the condensed form into a variable for each item
    in the data.

    Example
        ```
        ** Cluster assignments **
        cluster1 = {0,2,4}
        cluster2 = {1,3}

        ** Cluster indicators for perturbation **
        value[cluster1] = True
        value[cluster2] = False

        magnitude.value = -0.5

        &gt;&gt;&gt; np.ndarray([-0.5, 0, -0.5, 0, -0.5])
        ```
    
    Parameters
    ----------
    only_pos_ind : bool
        If this is True, then it will return only for when the indicator is positive

    Returns
    -------
    np.ndarray((n_c,), dtype=float)
        Array of the cluster perturbation values for each cluster
    &#39;&#39;&#39;
    ind = self.indicator.item_bool_array()
    if only_pos_ind:
        val = self.magnitude.item_array()[ind]
    else:
        val = np.zeros(len(self.clustering.items))
        val[ind] = self.magnitude.item_array()[ind]
    return val</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationEffect.remove_local_trace"><code class="name flex">
<span>def <span class="ident">remove_local_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the local trace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_local_trace(self):
    &#39;&#39;&#39;Delete the local trace
    &#39;&#39;&#39;
    self.trace = None</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationEffect.set_values_from_array"><code class="name flex">
<span>def <span class="ident">set_values_from_array</span></span>(<span>self, values:Â numpy.ndarray, use_indicators:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the values from an array of the same order as the clusters.</p>
<h2 id="paramters">Paramters</h2>
<p>values : array_like
An array of the values
Must be the same length as the number of clusters is <code>use_indicators</code>
is False. If <code>use_indicators</code> is True, then the length must correspond
to how many positive indicators there are.
use_indicators : bool
If True, the values
only correspond to positive interactions. Else
the values correspond to every cluster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_values_from_array(self, values: np.ndarray, use_indicators: bool=True):
    &#39;&#39;&#39;Sets the values from an array of the same order as the clusters.

    Paramters
    ---------
    values : array_like
        An array of the values
        Must be the same length as the number of clusters is `use_indicators` 
        is False. If `use_indicators` is True, then the length must correspond
        to how many positive indicators there are.
    use_indicators : bool
        If True, the values  only correspond to positive interactions. Else
        the values correspond to every cluster
    &#39;&#39;&#39;
    if not util.isarray(values):
        raise ValueError(&#39;`values` ({}) must be an array&#39;.format(type(values)))
    if not util.isbool(use_indicators):
        raise TypeError(&#39;`use_indicators` ({}) must be a bool&#39;.format(
            type(use_indicators)))
    if not use_indicators:
        # Checking is done within this function
        self.magnitude.set_values_from_array(values)
    else:
        if len(values) != self.indicator.num_on_clusters():
            raise ValueError(&#39;The length of the array ({}) does not correspond&#39; \
                &#39; to how many on indicators there are ({})&#39;.format(
                    len(values), self.indicator.num_on_clusters()))
        i = 0
        for cid in self.clustering.order:
            if self.indicator.value[cid]:
                self.magnitude.value[cid] = values[i]
                i += 1</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.base.BasePerturbation" href="base.html#mdsine2.pylab.base.BasePerturbation">BasePerturbation</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.base.BasePerturbation.isactive" href="base.html#mdsine2.pylab.base.BasePerturbation.isactive">isactive</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="variables.html#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="variables.html#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator"><code class="flex name class">
<span>class <span class="ident">ClusterPerturbationIndicator</span></span>
<span>(</span><span>probability:Â <a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a>, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends the <code>pylab.cluster.ClusterValue</code> object so that it works for being a
cluster perturbation indicator</p>
<p>Implements the <code>clusters_changed</code> function required by a ClusterProperty
and provides a direct pointer to the probability object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>probability</code></strong> :&ensp;<code>pl.variables.Variable</code></dt>
<dd>This is the variable object that holds the probability for a positive indicator</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>These are additional arguments for ClusterValue</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClusterPerturbationIndicator(ClusterValue):
    &#39;&#39;&#39;Extends the `pylab.cluster.ClusterValue` object so that it works for being a 
    cluster perturbation indicator
    
    Implements the `clusters_changed` function required by a ClusterProperty
    and provides a direct pointer to the probability object

    Parameters
    ----------
    probability : pl.variables.Variable
        This is the variable object that holds the probability for a positive indicator
    kwargs : dict
        These are additional arguments for ClusterValue
    &#39;&#39;&#39;
    def __init__(self, probability: variables.Variable, **kwargs):
        ClusterValue.__init__(self, dtype=bool, **kwargs)
        self.probability = probability

    def reset(self):
        &#39;&#39;&#39;Reset all of the values
        &#39;&#39;&#39;
        self.value = {}
        for cid in self.clustering.order:
            self.value[cid] = False

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def clusters_changed(self, cids_added: Iterator[int], cids_removed: Iterator[int]):
        &#39;&#39;&#39;Delete old clusters, sample from `probability` for the
        new clusters. We do not need to type check because it
        is self contained within pylab

        Parameters
        ----------
        cids_added (list(int))
            - These are a list of cluster ids to add
        cids_removed (list(int))
            - These are the cids that were removed
        &#39;&#39;&#39;
        for cid in cids_removed:
            self.value.pop(cid)
        for cid in cids_added:
            self.value[cid] = bool(npr.binomial(n=1, p=self.probability.value))

    def item_bool_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Creates a boolean array expanded so that each item has the same 
        value that the cluster that contains it has. This is the same as 
        calling ClusterValue.item_array
        Example
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; np.ndarray([True, False, True, False, True])
            ```

        Returns
        -------
        np.ndarray((n,), dtype=bool)
            A numpy bool array for each item
        &#39;&#39;&#39;
        return ClusterValue.item_array(self)

    def cluster_bool_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Creates a boolean array for each item in cluster order. This 
        is the same as calling ClusterValue.cluster_array()

        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; np.ndarray([True, False])
            ```
        
        Returns
        -------
        np.ndarray((n,), dtype=bool)
            A numpy bool array for each cluster
        &#39;&#39;&#39;
        return ClusterValue.cluster_array(self)

    def item_arg_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Creates an ordered index array of items that are positive.
        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; np.ndarray([0,2,4])
            ```

        Returns
        -------
        np.ndarray((n_c,), dtype=int)
            A numpy index array for each item
        &#39;&#39;&#39;
        val = []
        for cluster in self.clustering:
            if self.value[cluster.id]:
                val += list(cluster.members)
        return np.asarray(val, dtype=int)

    def cluster_arg_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Creates an ordered index array of clusters that are positive.
        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; np.ndarray([0])
            ```

        Returns
        -------
        np.ndarray((n_c,), dtype=int)
            A numpy index array for each cluster
        &#39;&#39;&#39;

        return np.asarray([idx for idx,cid in enumerate(self.clustering.order) \
            if self.value[cid]], dtype=int)

    def num_on_items(self) -&gt; int:
        &#39;&#39;&#39;These are the number of on items for this perturbation
        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; 3
            ```

        Returns
        -------
        int
            This is the number of postiive items
        &#39;&#39;&#39;
        try:
            cumm = 0
            for cluster in self.clustering:
                if self.value[cluster.id]:
                    cumm += cluster.size
            return int(cumm)
        except:
            logging.critical(&#39;Inner cluster ids:\n{}&#39;.format(list(self.value.keys())))
            logging.critical(&#39;Clustering cluster ids:\n{}&#39;.format(self.clustering.order))
            raise

    def num_on_clusters(self) -&gt; int:
        &#39;&#39;&#39;These are the number of on clusters for this perturbation
        Example:
            ```
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False
            &gt;&gt;&gt; 1
            ```

        Returns
        -------
        int
            This is the number of postiive clusters
        &#39;&#39;&#39;
        cumm = 0
        for cid in self.clustering.order:
            cumm += self.value[cid]
        return cumm

    def get_clusters_on(self) -&gt; Iterator[int]:
        &#39;&#39;&#39;Return the cluster IDs that have a positive indicator for this
        perturbation.

        Returns
        -------
        list(int)
        &#39;&#39;&#39;
        ret = [cid for cid in self.clustering.order if self.value[cid]]
        return ret

    def get_items_on(self) -&gt; Iterator[int]:
        &#39;&#39;&#39;Get the item indecies that have a positive indicator for this
        perturbation.

        Returns
        -------
        list(int)
        &#39;&#39;&#39;
        ret = []
        for cid in self.clustering.order:
            if self.value[cid]:
                ret += list(self.clustering.clusters[cid].members)
        return ret</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.cluster.ClusterValue" href="cluster.html#mdsine2.pylab.cluster.ClusterValue">ClusterValue</a></li>
<li><a title="mdsine2.pylab.cluster.ClusterProperty" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty">ClusterProperty</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.cluster_arg_array"><code class="name flex">
<span>def <span class="ident">cluster_arg_array</span></span>(<span>self) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an ordered index array of clusters that are positive.</p>
<h2 id="example">Example</h2>
<pre><code>cluster1 = {0,2,4}
cluster2 = {1,3}
value[cluster1] = True
value[cluster2] = False
```python-repl
&gt;&gt;&gt; np.ndarray([0])
</code></pre>
<p>```</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n_c,), dtype=int)</code></dt>
<dd>A numpy index array for each cluster</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_arg_array(self) -&gt; np.ndarray:
    &#39;&#39;&#39;Creates an ordered index array of clusters that are positive.
    Example:
        ```
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        &gt;&gt;&gt; np.ndarray([0])
        ```

    Returns
    -------
    np.ndarray((n_c,), dtype=int)
        A numpy index array for each cluster
    &#39;&#39;&#39;

    return np.asarray([idx for idx,cid in enumerate(self.clustering.order) \
        if self.value[cid]], dtype=int)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.cluster_bool_array"><code class="name flex">
<span>def <span class="ident">cluster_bool_array</span></span>(<span>self) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a boolean array for each item in cluster order. This
is the same as calling ClusterValue.cluster_array()</p>
<h2 id="example">Example</h2>
<pre><code>cluster1 = {0,2,4}
cluster2 = {1,3}
value[cluster1] = True
value[cluster2] = False
```python-repl
&gt;&gt;&gt; np.ndarray([True, False])
</code></pre>
<p>```</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n,), dtype=bool)</code></dt>
<dd>A numpy bool array for each cluster</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_bool_array(self) -&gt; np.ndarray:
    &#39;&#39;&#39;Creates a boolean array for each item in cluster order. This 
    is the same as calling ClusterValue.cluster_array()

    Example:
        ```
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        &gt;&gt;&gt; np.ndarray([True, False])
        ```
    
    Returns
    -------
    np.ndarray((n,), dtype=bool)
        A numpy bool array for each cluster
    &#39;&#39;&#39;
    return ClusterValue.cluster_array(self)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.clusters_changed"><code class="name flex">
<span>def <span class="ident">clusters_changed</span></span>(<span>self, cids_added:Â Iterator[int], cids_removed:Â Iterator[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Delete old clusters, sample from <code>probability</code> for the
new clusters. We do not need to type check because it
is self contained within pylab</p>
<h2 id="parameters">Parameters</h2>
<p>cids_added (list(int))
- These are a list of cluster ids to add
cids_removed (list(int))
- These are the cids that were removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clusters_changed(self, cids_added: Iterator[int], cids_removed: Iterator[int]):
    &#39;&#39;&#39;Delete old clusters, sample from `probability` for the
    new clusters. We do not need to type check because it
    is self contained within pylab

    Parameters
    ----------
    cids_added (list(int))
        - These are a list of cluster ids to add
    cids_removed (list(int))
        - These are the cids that were removed
    &#39;&#39;&#39;
    for cid in cids_removed:
        self.value.pop(cid)
    for cid in cids_added:
        self.value[cid] = bool(npr.binomial(n=1, p=self.probability.value))</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.get_clusters_on"><code class="name flex">
<span>def <span class="ident">get_clusters_on</span></span>(<span>self) â€‘>Â Iterator[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the cluster IDs that have a positive indicator for this
perturbation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list(int)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clusters_on(self) -&gt; Iterator[int]:
    &#39;&#39;&#39;Return the cluster IDs that have a positive indicator for this
    perturbation.

    Returns
    -------
    list(int)
    &#39;&#39;&#39;
    ret = [cid for cid in self.clustering.order if self.value[cid]]
    return ret</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.get_items_on"><code class="name flex">
<span>def <span class="ident">get_items_on</span></span>(<span>self) â€‘>Â Iterator[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the item indecies that have a positive indicator for this
perturbation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list(int)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_items_on(self) -&gt; Iterator[int]:
    &#39;&#39;&#39;Get the item indecies that have a positive indicator for this
    perturbation.

    Returns
    -------
    list(int)
    &#39;&#39;&#39;
    ret = []
    for cid in self.clustering.order:
        if self.value[cid]:
            ret += list(self.clustering.clusters[cid].members)
    return ret</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.item_arg_array"><code class="name flex">
<span>def <span class="ident">item_arg_array</span></span>(<span>self) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an ordered index array of items that are positive.</p>
<h2 id="example">Example</h2>
<pre><code>cluster1 = {0,2,4}
cluster2 = {1,3}
value[cluster1] = True
value[cluster2] = False
```python-repl
&gt;&gt;&gt; np.ndarray([0,2,4])
</code></pre>
<p>```</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n_c,), dtype=int)</code></dt>
<dd>A numpy index array for each item</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item_arg_array(self) -&gt; np.ndarray:
    &#39;&#39;&#39;Creates an ordered index array of items that are positive.
    Example:
        ```
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        &gt;&gt;&gt; np.ndarray([0,2,4])
        ```

    Returns
    -------
    np.ndarray((n_c,), dtype=int)
        A numpy index array for each item
    &#39;&#39;&#39;
    val = []
    for cluster in self.clustering:
        if self.value[cluster.id]:
            val += list(cluster.members)
    return np.asarray(val, dtype=int)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.item_bool_array"><code class="name flex">
<span>def <span class="ident">item_bool_array</span></span>(<span>self) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a boolean array expanded so that each item has the same
value that the cluster that contains it has. This is the same as
calling ClusterValue.item_array
Example
<code>cluster1 = {0,2,4}
cluster2 = {1,3}
value[cluster1] = True
value[cluster2] = False
&gt;&gt;&gt; np.ndarray([True, False, True, False, True])</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n,), dtype=bool)</code></dt>
<dd>A numpy bool array for each item</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item_bool_array(self) -&gt; np.ndarray:
    &#39;&#39;&#39;Creates a boolean array expanded so that each item has the same 
    value that the cluster that contains it has. This is the same as 
    calling ClusterValue.item_array
    Example
        ```
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        &gt;&gt;&gt; np.ndarray([True, False, True, False, True])
        ```

    Returns
    -------
    np.ndarray((n,), dtype=bool)
        A numpy bool array for each item
    &#39;&#39;&#39;
    return ClusterValue.item_array(self)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.num_on_clusters"><code class="name flex">
<span>def <span class="ident">num_on_clusters</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>These are the number of on clusters for this perturbation</p>
<h2 id="example">Example</h2>
<pre><code>cluster1 = {0,2,4}
cluster2 = {1,3}
value[cluster1] = True
value[cluster2] = False
```python-repl
&gt;&gt;&gt; 1
</code></pre>
<p>```</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>This is the number of postiive clusters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_on_clusters(self) -&gt; int:
    &#39;&#39;&#39;These are the number of on clusters for this perturbation
    Example:
        ```
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        &gt;&gt;&gt; 1
        ```

    Returns
    -------
    int
        This is the number of postiive clusters
    &#39;&#39;&#39;
    cumm = 0
    for cid in self.clustering.order:
        cumm += self.value[cid]
    return cumm</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.num_on_items"><code class="name flex">
<span>def <span class="ident">num_on_items</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>These are the number of on items for this perturbation</p>
<h2 id="example">Example</h2>
<pre><code>cluster1 = {0,2,4}
cluster2 = {1,3}
value[cluster1] = True
value[cluster2] = False
```python-repl
&gt;&gt;&gt; 3
</code></pre>
<p>```</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>This is the number of postiive items</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_on_items(self) -&gt; int:
    &#39;&#39;&#39;These are the number of on items for this perturbation
    Example:
        ```
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        &gt;&gt;&gt; 3
        ```

    Returns
    -------
    int
        This is the number of postiive items
    &#39;&#39;&#39;
    try:
        cumm = 0
        for cluster in self.clustering:
            if self.value[cluster.id]:
                cumm += cluster.size
        return int(cumm)
    except:
        logging.critical(&#39;Inner cluster ids:\n{}&#39;.format(list(self.value.keys())))
        logging.critical(&#39;Clustering cluster ids:\n{}&#39;.format(self.clustering.order))
        raise</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationIndicator.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset all of the values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#39;&#39;&#39;Reset all of the values
    &#39;&#39;&#39;
    self.value = {}
    for cid in self.clustering.order:
        self.value[cid] = False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.cluster.ClusterValue" href="cluster.html#mdsine2.pylab.cluster.ClusterValue">ClusterValue</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_trace" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.assignments_changed" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty.assignments_changed">assignments_changed</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.cluster_array" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.cluster_array">cluster_array</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.item_array" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.item_array">item_array</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.remove_local_trace" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_signal_when_clusters_change" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_clusters_change">set_signal_when_clusters_change</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_signal_when_item_assignment_changes" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_item_assignment_changes">set_signal_when_item_assignment_changes</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_trace" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_values_from_array" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.set_values_from_array">set_values_from_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationValue"><code class="flex name class">
<span>class <span class="ident">ClusterPerturbationValue</span></span>
<span>(</span><span>clustering:Â <a title="mdsine2.pylab.cluster.Clustering" href="cluster.html#mdsine2.pylab.cluster.Clustering">Clustering</a>, signal_when_clusters_change:Â bool, signal_when_item_assignment_changes:Â bool, dtype:Â TypeÂ =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code>pylab.cluster.ClusterValue</code> object so it works for reset and cluster
changed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClusterPerturbationValue(ClusterValue):
    &#39;&#39;&#39;Extends `pylab.cluster.ClusterValue` object so it works for reset and cluster
    changed
    &#39;&#39;&#39;
    def reset(self):
        &#39;&#39;&#39;Reset all of the values
        &#39;&#39;&#39;
        self.value = {}
        for cid in self.clustering.order:
            self.value[cid] = 0

    def clusters_changed(self, cids_added: Iterator[int], cids_removed: Iterator[int]):
        &#39;&#39;&#39;Delete old clusters, sample from `prior` for the
        new clusters. We do not need to type check because it
        is self contained within pylab

        Parameters
        ----------
        cids_added (list(int))
            - These are a list of cluster ids to add
        cids_removed (list(int))
            - These are the cids that were removed
        &#39;&#39;&#39;
        for cid in cids_removed:
            self.value.pop(cid)
        for cid in cids_added:
            self.value[cid] = self.prior.sample()

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.cluster.ClusterValue" href="cluster.html#mdsine2.pylab.cluster.ClusterValue">ClusterValue</a></li>
<li><a title="mdsine2.pylab.cluster.ClusterProperty" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty">ClusterProperty</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationValue.clusters_changed"><code class="name flex">
<span>def <span class="ident">clusters_changed</span></span>(<span>self, cids_added:Â Iterator[int], cids_removed:Â Iterator[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Delete old clusters, sample from <code>prior</code> for the
new clusters. We do not need to type check because it
is self contained within pylab</p>
<h2 id="parameters">Parameters</h2>
<p>cids_added (list(int))
- These are a list of cluster ids to add
cids_removed (list(int))
- These are the cids that were removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clusters_changed(self, cids_added: Iterator[int], cids_removed: Iterator[int]):
    &#39;&#39;&#39;Delete old clusters, sample from `prior` for the
    new clusters. We do not need to type check because it
    is self contained within pylab

    Parameters
    ----------
    cids_added (list(int))
        - These are a list of cluster ids to add
    cids_removed (list(int))
        - These are the cids that were removed
    &#39;&#39;&#39;
    for cid in cids_removed:
        self.value.pop(cid)
    for cid in cids_added:
        self.value[cid] = self.prior.sample()</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.ClusterPerturbationValue.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset all of the values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#39;&#39;&#39;Reset all of the values
    &#39;&#39;&#39;
    self.value = {}
    for cid in self.clustering.order:
        self.value[cid] = 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.cluster.ClusterValue" href="cluster.html#mdsine2.pylab.cluster.ClusterValue">ClusterValue</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_trace" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.assignments_changed" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty.assignments_changed">assignments_changed</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.cluster_array" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.cluster_array">cluster_array</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.item_array" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.item_array">item_array</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.remove_local_trace" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_signal_when_clusters_change" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_clusters_change">set_signal_when_clusters_change</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_signal_when_item_assignment_changes" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_item_assignment_changes">set_signal_when_item_assignment_changes</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_trace" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterValue.set_values_from_array" href="cluster.html#mdsine2.pylab.cluster.ClusterValue.set_values_from_array">set_values_from_array</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions"><code class="flex name class">
<span>class <span class="ident">Interactions</span></span>
<span>(</span><span>clustering:Â <a title="mdsine2.pylab.cluster.Clustering" href="cluster.html#mdsine2.pylab.cluster.Clustering">Clustering</a>, use_indicators:Â bool, value_initializer:Â CallableÂ =Â None, indicator_initializer:Â CallableÂ =Â None, signal_when_clusters_change:Â boolÂ =Â True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a basic class for interactions between clusters.</p>
<p>This is a 2D dictionary. The first level of the dictionary indexes the target
cluster and the second level indexes the source cluster. You can make this 2
layer dictionary into a matrix or a vector with functions defined in this class.
The reason why the data is stored in a 2D dictionary is because the number of
clusters changes constantly, so inserting and deleting values in a dictionary is more
efficient than using a matrix/pandas.DataFrame. Additionally, the order of the clusters
are changing constantly. Having them as a 2D dictionary allows us to reference the
interactions in the same order as the clusters as they are defined in <code>clusters</code>.</p>
<h2 id="tracing">Tracing</h2>
<p>The interactions get traced on an item-item bases. In this class we assume there are no
interactions within a cluster. If the indicator is False, we set the trace to np.nan.
To get the indicators call <code>np.nan_to_num</code> on the trace. We do not trace the indicators
separately, but you can get the trace of the interactions by calling ~np.isnan(self.trace).</p>
<h2 id="indicators">Indicators</h2>
<p>You can choose whether to use or not use indicators for the interactions. If you choose
not to use the indicators, then we assume that every indicator is positive.</p>
<h2 id="iterators">Iterators</h2>
<p>These interactions assume the following order during iterating:
For target cluster in clusters:
For source cluster in clusters:
if they are the same cluster, skip
else yield value[target][source]
Clusters are ordered in the same way as clustering.</p>
<h2 id="value-and-indicator-initialization">Value And Indicator Initialization</h2>
<p>The values and indicators for a new interaction that gets made need to be initialized to
a value so we use the parameters <code>value_initializer</code> and
<code>inidicator_initializer</code>. If they
are not specified then we return <code>np.nan</code> During initialization of the inference these are
usually set to the priors of the variables.</p>
<p>The initializer for the indicator is assumed to either return a <code>bool</code> or a float betwen
[0,1]. It will set it to true if the sampled value is &gt;= 0.5. There is no checking for
this though.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clustering</code></strong> :&ensp;<code>Clustering</code></dt>
<dd>Clustering object</dd>
<dt><strong><code>use_indicators</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, use indicators. If False do not use indicators (automatically sets all indicators)
to True</dd>
<dt><strong><code>value_initializer</code></strong> :&ensp;<code>callable, None</code></dt>
<dd>This is the function that initializes the value of the <code>value</code> attribute for an interaction.
During MCMC you could set this to the sample method of the prior.
Defaults always returning np.nan.</dd>
<dt><strong><code>indicator_initializer</code></strong> :&ensp;<code>callable, None</code></dt>
<dd>This is the function that initializes the value of the <code>value</code> attribute for an interaction.
During MCMC you could set this to the sample method of the prior.
<br>
Defaults to always returning True</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interactions(ClusterProperty, Node, Traceable):
    &#39;&#39;&#39;This is a basic class for interactions between clusters.

    This is a 2D dictionary. The first level of the dictionary indexes the target 
    cluster and the second level indexes the source cluster. You can make this 2 
    layer dictionary into a matrix or a vector with functions defined in this class. 
    The reason why the data is stored in a 2D dictionary is because the number of 
    clusters changes constantly, so inserting and deleting values in a dictionary is more
    efficient than using a matrix/pandas.DataFrame. Additionally, the order of the clusters
    are changing constantly. Having them as a 2D dictionary allows us to reference the 
    interactions in the same order as the clusters as they are defined in `clusters`.

    Tracing
    -------
    The interactions get traced on an item-item bases. In this class we assume there are no
    interactions within a cluster. If the indicator is False, we set the trace to np.nan.
    To get the indicators call `np.nan_to_num` on the trace. We do not trace the indicators 
    separately, but you can get the trace of the interactions by calling ~np.isnan(self.trace).

    Indicators
    ----------
    You can choose whether to use or not use indicators for the interactions. If you choose
    not to use the indicators, then we assume that every indicator is positive.

    Iterators
    ---------
    These interactions assume the following order during iterating:
        For target cluster in clusters:
            For source cluster in clusters:
                if they are the same cluster, skip
                else yield value[target][source]
    Clusters are ordered in the same way as clustering.

    Value and indicator initialization
    ----------------------------------
    The values and indicators for a new interaction that gets made need to be initialized to 
    a value so we use the parameters `value_initializer` and  `inidicator_initializer`. If they
    are not specified then we return `np.nan` During initialization of the inference these are 
    usually set to the priors of the variables.

    The initializer for the indicator is assumed to either return a `bool` or a float betwen 
    [0,1]. It will set it to true if the sampled value is &gt;= 0.5. There is no checking for 
    this though.

    Parameters
    ----------
    clustering : Clustering
        Clustering object
    use_indicators : bool
        If True, use indicators. If False do not use indicators (automatically sets all indicators)
        to True
    value_initializer : callable, None
        This is the function that initializes the value of the `value` attribute for an interaction. 
        During MCMC you could set this to the sample method of the prior. 
        Defaults always returning np.nan.
    indicator_initializer : callable, None
        This is the function that initializes the value of the `value` attribute for an interaction. 
        During MCMC you could set this to the sample method of the prior.         
        Defaults to always returning True
    &#39;&#39;&#39;
    def __init__(self, clustering: Clustering, use_indicators: bool, 
        value_initializer: Callable=None, indicator_initializer: Callable=None, 
        signal_when_clusters_change: bool=True, **kwargs):

        Node.__init__(self, **kwargs)
        ClusterProperty.__init__(self, clustering=clustering, 
            signal_when_clusters_change=signal_when_clusters_change, 
            signal_when_item_assignment_changes=False)

        if value_initializer is None:
            value_initializer = _always_return_nan
        if indicator_initializer is None:
            indicator_initializer = _always_return_nan
        if not np.all(util.itercheck([value_initializer, indicator_initializer], callable)):
            raise TypeError(&#39;`value_initializer` ({}) and `indicator_initializer` ({}) &#39; \
                &#39;must be callable&#39;.format(type(value_initializer), 
                type(indicator_initializer)))

        self.value_initializer = value_initializer # function (callable)
        self.indicator_initializer = indicator_initializer # function (callable)
        self._IIDX = 1001001 # Index of the interactions
        
        if not util.isbool(use_indicators):
            raise TypeError(&#39;`use_indicators` ({}) must be a bool&#39;.format(type(use_indicators)))
        self.use_indicators = use_indicators # bool
        if not self.use_indicators:
            self.indicator_initializer = _always_return_true

        order = self.clustering.order

        # dict of a dict mapping to _Interaction objects
        # (target cluster, source cluster) -&gt; interaction
        self.value = {}
        for tcid in order:
            self.value[tcid] = {}
            for scid in order:
                if tcid == scid:
                    continue
                self.value[tcid][scid] = _Interaction( 
                    source_cid=scid, target_cid=tcid,
                    value=self.value_initializer(),
                    indicator=self.indicator_initializer(),
                    iden=self._IIDX)
                self._IIDX += 1

        self._shape = (len(self.clustering.items), len(self.clustering.items))
        self.dtype = float

    def __getitem__(self, key: Any) -&gt; &#39;_Interaction&#39;:
        return self.value[key]

    def __setitem__(self, key, val):
        self.value[key] = val

    def __iter__(self) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Iterates over the interactions in order
        &#39;&#39;&#39;
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    yield temp[scid]

    def __str__(self) -&gt; str:
        s=&#39;&#39;
        for interaction in self:
            s += str(interaction) + &#39;\n&#39;
        return s
    
    @property
    def size(self) -&gt; int:
        &#39;&#39;&#39;Return how many interactions there are possible according to the number of clusters.
        THIS IS NOT HOW MANY POSITIVE INTERACTIONS THERE ARE - USE `num_pos_interactions`

        Returns
        -------
        int
        &#39;&#39;&#39;
        n_clusters = len(self.clustering)
        return n_clusters * (n_clusters - 1)

    def iter_valid(self) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Iterate only over the positive indicators
        &#39;&#39;&#39;
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    if temp[scid].indicator:
                        yield temp[scid]

    def iter_valid_pairs(self) -&gt; Tuple[int, int]:
        &#39;&#39;&#39;Iterate only over the positive indicators
        &#39;&#39;&#39;
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    if temp[scid].indicator:
                        yield tcid, scid

    def iter_to_target(self, cid: int, only_valid: bool=False) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Iterates over interactions to the target cluster from all
        source clusters in the order specified by clusters

        Paramters
        ---------
        cid : int
            This is the target cluster id we are iterating from
        only_valid : bool
            If True, only returns the interactions with a positive indicator
        &#39;&#39;&#39;
        order = self.clustering.order
        temp = self.value[cid] # For quicker pointer
        if only_valid:
            for scid in order:
                if scid != cid:
                    if temp[scid].indicator:
                        yield temp[scid]
        else:
            for scid in order:
                if scid != cid:
                    yield temp[scid]

    def iter_from_source(self, cid: int, only_valid: bool=False) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Iterates over interactions from the source cluster to all
        target clusters in the order specified by clusters

        Paramters
        ---------
        cid (int)
            This is the source cluster id
        only_valid : bool
            If True, only returns the interactions with a positive indicator
        &#39;&#39;&#39;
        order = self.clustering.order
        if only_valid:
            for tcid in order:
                if tcid != cid:
                    if self.value[tcid][cid].indicator:
                        yield self.value[tcid][cid]
        else:
            for tcid in order:
                if tcid != cid:
                    yield self.value[tcid][cid]

    def reset(self):
        &#39;&#39;&#39;Reset all of the interactions
        &#39;&#39;&#39;
        self.value = {}
        for tcid in self.clustering.order:
            self.value[tcid] = {}
            for scid in self.clustering.order:
                if tcid == scid:
                    continue
                self.value[tcid][scid] = _Interaction(
                    source_cid=scid, target_cid=tcid,
                    value=self.value_initializer(),
                    indicator=self.indicator_initializer()&gt;=.5, 
                    iden=self._IIDX)
                self._IIDX += 1

    def iloc(self, idx: int) -&gt; &#34;_Interaction&#34;:
        &#39;&#39;&#39;Get the interaction as a function of the index that it occurs at.
        Reverse indexing is allowed.

        Parameters
        ----------
        idx : int
            This is the index that the interaction occurs at

        Returns
        -------
        pylab.contrib._Interaction
        &#39;&#39;&#39;
        if not util.isint(idx):
            raise TypeError(&#39;`idx` ({}) must be an int&#39;.format(idx))
        if idx &gt;= self.size:
            raise ValueError(&#39;`idx` ({}) cannot be &gt;= the number of interactions ({})&#39;.format(
                idx, self.size))
        if idx &lt; 0:
            idx = self.size - idx
        tcidx = idx // (len(self.clustering) - 1)
        scidx = idx - tcidx * (len(self.clustering) - 1)
        if scidx &gt;= tcidx:
            scidx += 1
        return self.value[
            self.clustering.order[tcidx]][
            self.clustering.order[scidx]]

    def clusters_changed(self, cids_added: Iterator[int], cids_removed: Iterator[int]):
        &#39;&#39;&#39;Remove all of the interactions to and from the clusters
        in `cids_removed` and make interactions for the `cid_added`

        Parameters
        ----------
        cids_removed : list(int)
            IDs of the clusters removed
        cids_added : list(int)
            IDs of the clusters added
        &#39;&#39;&#39;
        # Remove interactions from clusters deleted
        if len(cids_removed) &gt; 0:
            for cid in cids_removed:
                self.value.pop(cid, None)
            for cid in self.value.keys():
                for cid_del in cids_removed:
                    self.value[cid].pop(cid_del, None)
        if len(cids_added) &gt; 0:
            for cid in cids_added:
                self._add_single_cluster(cid)
        
    def _add_single_cluster(self, cid: int):
        other_cids = self.value.keys()
        # Add the interaction from clusters already there and 
        # the new cluster
        for ocid in other_cids:
            self.value[ocid][cid] = _Interaction(
                source_cid=cid, target_cid=ocid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer() &gt;= 0.5,
                iden=self._IIDX)
            self._IIDX += 1
        self.value[cid] = {}
        for ocid in other_cids:
            self.value[cid][ocid] = _Interaction(
                source_cid=ocid, target_cid=cid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer() &gt;= 0.5,
                iden=self._IIDX)
            self._IIDX += 1
    
    def key_pairs(self, only_valid: bool=False) -&gt; Iterator[Tuple[int, int]]:
        &#39;&#39;&#39;Returns (target,source) cluster ids in order

        Parameters
        ----------
        only_valid : bool
            If True, it will only return the key pairs that have a positive indicator.
            Else it will return all of the interactions regardless of the indicator.

        Returns 
        -------
        list((int,int))
            Return a list of the (target, source) cluster IDs for each interaciton
            in order.
        &#39;&#39;&#39;
        order = self.clustering.order
        l = []
        for tcid in order:
            for scid in order:
                if tcid != scid:
                    if only_valid:
                        if self.value[tcid][scid].indicator:
                            l.append((tcid, scid))
                    else:
                        l.append((tcid,scid))
        return l

    def num_neg_indicators(self, target_cid: int=None) -&gt; int:
        &#39;&#39;&#39;Return the number of indicator variables that are 0

        If target_cid is not None, calculate them for only the interactions going into
        that cluster

        Paramters
        ---------
        target_cid : int, Optional
            If this is specified, get only the negative indicators going into the cluster 
            `target_cid`
        &#39;&#39;&#39;
        cumm = 0
        if target_cid is not None:
            for interaction in self.iter_to_target(target_cid):
                cumm += not interaction.indicator
        else:
            for interaction in self:
                cumm += not interaction.indicator
        return cumm

    def num_pos_indicators(self, target_cid: int=None) -&gt; int:
        &#39;&#39;&#39;Return the number of indicator variables that are 1

        If target_cid is not None, calculate them for only the interactions going into
        that cluster

        Paramters
        ---------
        target_cid : int, Optional
            If this is specified, get only the positive indicators going into the cluster 
            `target_cid`
        &#39;&#39;&#39;
        cumm = 0
        if target_cid is not None:
            for interaction in self.iter_to_target(target_cid):
                cumm += interaction.indicator
        else:
            for interaction in self:
                cumm += interaction.indicator
        return cumm

    def get_arg_indicators(self, target_cid: int=None, source_cid: int=None) -&gt; Iterator[int]:
        &#39;&#39;&#39;Get the positive indicators as indices, in order -&gt; same convention
        as `get_indicators`.

        If `target_cid` is specfied, it will get all of the positive indicator indicies 
        going to the target cluster `target_cid` in order. If `source_cid` is specified,
        then it will get all of the positive indicator indices going to the source cluster 
        `source_cid` in order. If both `target_cid` and `source_cid` are specified,
        it will return an empty array if the indicator is False or it will return
        an array of size 1 if the indicator is True.

        Parameters
        ----------
        target_cid, source_cid : int, None
            These are the target cluster ID and source cluster ID, respectively.
            If None then nothing is specified.

        Returns
        -------
        list(int)
            Returns a list of the interactions that are positive in order
        &#39;&#39;&#39;
        ret = []
        try:
            if target_cid is not None:
                n_clusters = len(self.clustering)
                tcidx = self.clustering.cid2cidx[target_cid]

                if source_cid is not None:
                    if self.value[target_cid][source_cid].indicator:
                        scidx = self.clustering.cid2cidx[source_cid]
                        if tcidx &lt; scidx:
                            scidx -= 1
                        iidx = tcidx * (n_clusters - 1) + scidx
                        ret.append(iidx)
                else:
                    base_idx = tcidx * (n_clusters - 1)
                    for offset, interaction in enumerate(self.iter_to_target(target_cid)):
                        if interaction.indicator:
                            ret.append(base_idx + offset)
            
            elif source_cid is not None:
                # We do not need to check if target_cid is not None because 
                # it would have been covered in the previous check
                scidx = self.clustering.cid2cidx[source_cid]
                for interaction in self.iter_from_source(source_cid):
                    if interaction.indicator:
                        tcidx = self.clustering.cid2cidx[interaction.target_cid]

                        iidx = tcidx * (n_clusters - 1) + scidx
                        if scidx &gt; tcidx:
                            iidx -= 1
                        ret.append(iidx)

            else:
                for idx, interaction in enumerate(self):
                    if interaction.indicator:
                        ret.append(idx)
            return ret
        except:
            # Check to see if it is a key error, else it is something weird
            if target_cid is not None or source_cid is not None:
                if not util.isint(target_cid) or not util.isint(source_cid):
                    raise TypeError(&#39;`Either `target_cid` ({}) or `source_cid` ({})&#39; \
                        &#39; must be an int&#39;.format(type(target_cid), type(source_cid)))
                elif target_cid == source_cid:
                    raise ValueError(&#39;`target_cid` ({}) and `source_cid` ({}) cannot&#39; \
                        &#39; be the same&#39;.format(target_cid, source_cid))
            raise

    def get_indicators(self, target_cid: int=None, source_cid: int=None,
        return_idxs: bool=False) -&gt; Iterator[bool]:
        &#39;&#39;&#39;Return a the indicator variables as a vector in the order specified
        by the clusters.

        if `target_cid` is specified then it will return all indicators going
        to that cluster. If `source_cid` is specified then it will return all
        indicators going from that cluster. If both are specifeid then it
        will return an array of size 1 of a bool

        Parameters
        ----------
        target_cid, source_cid : int, None
            These are the target cluster ID and source cluster ID, respectively.
            If None then nothing is specified.
        return_idxs : bool
            If True, we return the index of the positive indicators. If False we 
            return an array of the indicator flags for every interaction. Nothing
            is done if both `target_cid` and `source_cid` are specified

        Returns
        -------
        np.ndarray(n, dtype=bool)
            Returns a bool vector of the indicators in roder
        &#39;&#39;&#39;
        if target_cid is not None or source_cid is not None and return_idxs:
            mapping = {}
            order = self.clustering.order
            i = 0
            for tcid in order:
                for scid in order:
                    if tcid == scid:
                        continue
                    mapping[(tcid, scid)] = i
                    i += 1
            
        try:
            if target_cid is not None:
                if source_cid is not None:
                    ret = np.asarray([self.value[target_cid][source_cid].indicator])
                else:
                    if return_idxs:
                        ret = []
                    else:
                        l = len(self.clustering) - 1
                        ret = np.zeros(l, dtype=bool)
                    for iidx, interaction in enumerate(self.iter_to_target(target_cid)):
                        if interaction.indicator:
                            if return_idxs:
                                ret.append(mapping[(target_cid, interaction.source_cid)])
                            else:
                                ret[iidx] = True
            elif source_cid is not None:
                # We do not need to check if target_cid is not None because 
                # it would have been covered in the previous check
                if return_idxs:
                    ret = []
                else:
                    l = len(self.clustering) - 1
                    ret = np.zeros(l, dtype=bool)
                for iidx, interaction in enumerate(self.iter_from_source(source_cid)):
                    if interaction.indicator:
                        if return_idxs:
                            ret.append(mapping[(interaction.target_cid, source_cid)])
                        else:
                            ret[iidx] = True

            else:
                if return_idxs:
                    ret = []
                else:
                    ret = np.zeros(self.size, dtype=bool)
                for idx, interaction in enumerate(self):
                    if interaction.indicator:
                        if return_idxs:
                            ret.append(idx)
                        else:
                            ret[idx] = True
                return ret
            if return_idxs:
                ret = np.asarray(ret, dtpye=int)
            return ret

        except:
            # Check to see if it is a key error, else it is something weird
            if target_cid is not None or source_cid is not None:
                if not util.isint(target_cid) or not util.isint(source_cid):
                    raise TypeError(&#39;`Either `target_cid` ({}) or `source_cid` ({})&#39; \
                        &#39; must be an int&#39;.format(type(target_cid), type(source_cid)))
                elif target_cid == source_cid:
                    raise ValueError(&#39;`target_cid` ({}) and `source_cid` ({}) cannot&#39; \
                        &#39; be the same&#39;.format(target_cid, source_cid))
            raise

    def set_indicators(self, arr: np.ndarray):
        &#39;&#39;&#39;Sets the values of the indicators of the interactions from a vector.

        If `include_self_interactions` is True, assumes that `arr` contains the
        values for the self interactions. If False, assume that the indices are
        skipped.

        Paramters
        ---------
        arr : np.ndarray(n, dtpye=bool)
            These are the indicator values to set, in order
        &#39;&#39;&#39;
        if len(arr) != self.size:
            raise ValueError(&#39;The number of elements in `arr` ({}) is not the &#39; \
                &#39;same as the number of interactions ({})&#39;.format(len(arr), self.size))
        for idx, interaction in enumerate(self):
            interaction.indicator = arr[idx]
            if interaction.indicator == 0:
                interaction.value = 0

    def set_values(self, arr: np.ndarray, use_indicators: bool=True):
        &#39;&#39;&#39;Sets the values of the interactions from a vector.

        If `use_indicators` is True, assumes that the values in the vector only contain
        values for interactions where the indicator variable is positive and the
        rest are skipped. If False, assumes the vector has values for where the
        indicator variables are positive and negative (all).

        Paramters
        ---------
        arr : np.ndarray(n, dtpye=float)
            These are the interaction values to set, in order
        use_indicators : bool, Optional
            If True, we only set the interactions with a positive indicator. Else we set every
            single interaction
        &#39;&#39;&#39;
        if not use_indicators:
            if len(arr) != self.size:
                raise ValueError(&#39;The number of elements in `arr` ({}) is not the &#39; \
                    &#39;same as the number of interactions ({})&#39;.format(len(arr), self.size))
            for idx, interaction in enumerate(self):
                interaction.value = arr[idx]
        else:
            # Dont check because it is too computationally intensive
            idx = 0
            for interaction in self:
                if not interaction.indicator:
                    continue
                interaction.value = arr[idx]
                idx += 1

    def get_values(self, use_indicators: bool=True) -&gt; np.ndarray:
        &#39;&#39;&#39;Makes a vector of the interaction variables in the order of the
        clustering

        if use_indicators is True, it skips over the indices that have a negative
        indicator variable. if it is True, it goes over everthing

         Paramters
        ---------
        use_indicators : bool, Optional
            If True, we only return the interactions with a positive indicator. Else we get every
            single interaction

        Returns
        -------
        np.ndarray(n, dtype=float)
            Array of the interaction values, in order
        &#39;&#39;&#39;
        ret = np.zeros(self.size)
        idx = 0
        if use_indicators:
            for interaction in self.iter_valid():
                ret[idx] = interaction.value
                idx += 1
        else:
            for interaction in self:
                ret[idx] = interaction.value
                idx += 1
        # Trim if necessary
        return ret[:idx]

    def get_value_matrix(self, set_neg_indicators_to_nan: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Get the interaction matrix at the clustert level (item-item). 
        The ordering of the clusters is the same as it is in clustering

        If `set_neg_indicators_to_nan` is True, interactions that have a negative
        indicator are set to np.nan. Else, they are set to 0.

        Parameters
        ----------
        set_neg_indicators_to_nan : bool
            If True, it will set the negative interaction indicator values to 
            np.nan. Else, it will set them to 0.

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the item-item interaction value matrix
        &#39;&#39;&#39;
        n_clusters = len(self.clustering)
        if set_neg_indicators_to_nan:
            fill = np.nan
        else:
            fill = 0
        ret = np.full(shape=(n_clusters, n_clusters), fill_value=fill, dtype=float)
        for interaction in self:
            if not interaction.indicator:
                continue
            tcidx = self.clustering.cid2cidx[interaction.target_cid]
            scidx = self.clustering.cid2cidx[interaction.source_cid]
            ret[tcidx, scidx] = interaction.value
        return ret

    def get_datalevel_value_matrix(self, set_neg_indicators_to_nan: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Get the interaction matrix at the data level (item-item), not
        at the cluster level. The ordering of the items is the same as 
        it is in the items in clustering (self.clustering.times).

        If `set_neg_indicators_to_nan` is True, interactions that have a negative
        indicator are set to np.nan. Else, they are set to 0.

        Parameters
        ----------
        set_neg_indicators_to_nan : bool
            If True, it will set the negative interaction indicator values to 
            np.nan. Else, it will set them to 0.

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the item-item interaction value matrix
        &#39;&#39;&#39;
        n_items = len(self.clustering.items)
        if set_neg_indicators_to_nan:
            fill = np.nan
        else:
            fill = 0
        ret = np.full(shape=(n_items, n_items), fill_value=fill, dtype=float)
        for interaction in self:
            if not interaction.indicator:
                continue
            val = interaction.value
            for tidx in self.clustering.clusters[interaction.target_cid].members:
                for sidx in self.clustering.clusters[interaction.source_cid].members:
                    ret[tidx, sidx] = val
        return ret
    
    def get_datalevel_indicator_matrix(self) -&gt; np.ndarray:
        &#39;&#39;&#39;Get the item-item indicator matrix.

        The ordering of the items are the same as the order in
        self.clusters.items.ids.order

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the item-item interaction value matrix
        &#39;&#39;&#39;
        n_items = len(self.clustering.items)
        ret = np.zeros(shape=(n_items, n_items), dtype=bool)
        for interaction in self:
            if not interaction.indicator:
                continue
            for tidx in self.clustering.clusters[interaction.target_cid].members:
                for sidx in self.clustering.clusters[interaction.source_cid].members:
                    ret[tidx, sidx] = True
        return ret

    def generate_in_out_degree_posthoc(self, section: str=&#39;posterior&#39;) -&gt; Dict[str, np.ndarray]:
        &#39;&#39;&#39;Returns a dictionary of arrays
        &#34;in&#34;
            For each index in the array, corresponding to the index of the items, returns
            the number of incoming interactions for each iteration of the item
        &#34;out&#34;
            For each index in the array, corresponding to the index of the items, returns
            the number of outgoing interactions for each iteration of the item

        Parameters
        ----------
        section : str
            Which section of the inference you want to choose. 
            Options:
                &#39;posterior&#39;
                    Only look at the posterior
                &#39;burnin&#39;
                    Returns the samples that were in the burnin
                &#39;entire&#39;
                    Returns all the samples
        &#39;&#39;&#39;
        trace = self.get_trace_from_disk(section=section)
        trace = ~np.isnan(trace)
        return {&#39;in&#39;: np.sum(trace, axis=2), &#39;out&#39;:np.sum(trace, axis=1)}

    def set_trace(self):
        &#39;&#39;&#39;Initialize the trace arrays for the variable in the Tracer object. 

        It will initialize a buffer the size of the checkpoint size in Tracer
        &#39;&#39;&#39;
        tracer = self.G.tracer
        tracer.set_trace(self.name, shape=self._shape, dtype=self.dtype)

        self.ckpt_iter = 0
        self.sample_iter = 0
        shape = (tracer.checkpoint, ) + self._shape
        self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def add_trace(self):
        &#39;&#39;&#39;Adds the current value to the trace. If the buffer is full
        it will end it to disk
        &#39;&#39;&#39;
        self.trace[self.ckpt_iter] = self.get_datalevel_value_matrix(set_neg_indicators_to_nan=True)
        self.ckpt_iter += 1
        self.sample_iter += 1
        if self.ckpt_iter == len(self.trace):
            # We have gotten the largest we can in the local buffer, write to disk
            self.G.tracer.write_to_disk(name=self.name)
            shape = (self.G.tracer.checkpoint, ) + self._shape
            self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)
            self.ckpt_iter = 0

    def get_adjacent(self, cid: int, incoming: bool, outgoing: bool, 
        use_indicators: bool=True) -&gt; Iterator[int]:
        &#39;&#39;&#39;Get all of the cluster IDs that have a positive interaction going into
        or from the cluster `cid`.

        Parameters
        ----------
        cid : int
            This is the Cluster ID you want to get the adjacent clusters of
        incoming : bool 
            Get the cids of the incoming edges
        outgoing : bool
            Get the cids of the outgoing edges
        use_indicators : bool
            If this is True then if the indicator is False then we do not include.
            If this is False then we always include the interaction

        Returns
        -------
        list
            List of cids
        &#39;&#39;&#39;
        if cid not in self.clustering.order:
            raise ValueError(&#39;`cid` ({}) not found&#39;.format(cid))
        cids = []
        if incoming:
            for interaction in self.iter_from_source(cid):
                if interaction.indicator or not use_indicators:
                    cids.append(interaction.target_cid)
        if outgoing:
            for interaction in self.iter_to_target(cid):
                if interaction.indicator or not use_indicators:
                    cids.append(interaction.source_cid)
        return cids</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.cluster.ClusterProperty" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty">ClusterProperty</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.contrib.Interactions.size"><code class="name">var <span class="ident">size</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Return how many interactions there are possible according to the number of clusters.
THIS IS NOT HOW MANY POSITIVE INTERACTIONS THERE ARE - USE <code>num_pos_interactions</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#39;&#39;&#39;Return how many interactions there are possible according to the number of clusters.
    THIS IS NOT HOW MANY POSITIVE INTERACTIONS THERE ARE - USE `num_pos_interactions`

    Returns
    -------
    int
    &#39;&#39;&#39;
    n_clusters = len(self.clustering)
    return n_clusters * (n_clusters - 1)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.contrib.Interactions.clusters_changed"><code class="name flex">
<span>def <span class="ident">clusters_changed</span></span>(<span>self, cids_added:Â Iterator[int], cids_removed:Â Iterator[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all of the interactions to and from the clusters
in <code>cids_removed</code> and make interactions for the <code>cid_added</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cids_removed</code></strong> :&ensp;<code>list(int)</code></dt>
<dd>IDs of the clusters removed</dd>
<dt><strong><code>cids_added</code></strong> :&ensp;<code>list(int)</code></dt>
<dd>IDs of the clusters added</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clusters_changed(self, cids_added: Iterator[int], cids_removed: Iterator[int]):
    &#39;&#39;&#39;Remove all of the interactions to and from the clusters
    in `cids_removed` and make interactions for the `cid_added`

    Parameters
    ----------
    cids_removed : list(int)
        IDs of the clusters removed
    cids_added : list(int)
        IDs of the clusters added
    &#39;&#39;&#39;
    # Remove interactions from clusters deleted
    if len(cids_removed) &gt; 0:
        for cid in cids_removed:
            self.value.pop(cid, None)
        for cid in self.value.keys():
            for cid_del in cids_removed:
                self.value[cid].pop(cid_del, None)
    if len(cids_added) &gt; 0:
        for cid in cids_added:
            self._add_single_cluster(cid)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.generate_in_out_degree_posthoc"><code class="name flex">
<span>def <span class="ident">generate_in_out_degree_posthoc</span></span>(<span>self, section:Â strÂ =Â 'posterior') â€‘>Â Dict[str,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary of arrays
"in"
For each index in the array, corresponding to the index of the items, returns
the number of incoming interactions for each iteration of the item
"out"
For each index in the array, corresponding to the index of the items, returns
the number of outgoing interactions for each iteration of the item</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>section</code></strong> :&ensp;<code>str</code></dt>
<dd>Which section of the inference you want to choose.
Options:
'posterior'
Only look at the posterior
'burnin'
Returns the samples that were in the burnin
'entire'
Returns all the samples</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_in_out_degree_posthoc(self, section: str=&#39;posterior&#39;) -&gt; Dict[str, np.ndarray]:
    &#39;&#39;&#39;Returns a dictionary of arrays
    &#34;in&#34;
        For each index in the array, corresponding to the index of the items, returns
        the number of incoming interactions for each iteration of the item
    &#34;out&#34;
        For each index in the array, corresponding to the index of the items, returns
        the number of outgoing interactions for each iteration of the item

    Parameters
    ----------
    section : str
        Which section of the inference you want to choose. 
        Options:
            &#39;posterior&#39;
                Only look at the posterior
            &#39;burnin&#39;
                Returns the samples that were in the burnin
            &#39;entire&#39;
                Returns all the samples
    &#39;&#39;&#39;
    trace = self.get_trace_from_disk(section=section)
    trace = ~np.isnan(trace)
    return {&#39;in&#39;: np.sum(trace, axis=2), &#39;out&#39;:np.sum(trace, axis=1)}</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.get_adjacent"><code class="name flex">
<span>def <span class="ident">get_adjacent</span></span>(<span>self, cid:Â int, incoming:Â bool, outgoing:Â bool, use_indicators:Â boolÂ =Â True) â€‘>Â Iterator[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all of the cluster IDs that have a positive interaction going into
or from the cluster <code>cid</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cid</code></strong> :&ensp;<code>int</code></dt>
<dd>This is the Cluster ID you want to get the adjacent clusters of</dd>
<dt><strong><code>incoming</code></strong> :&ensp;<code>bool </code></dt>
<dd>Get the cids of the incoming edges</dd>
<dt><strong><code>outgoing</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get the cids of the outgoing edges</dd>
<dt><strong><code>use_indicators</code></strong> :&ensp;<code>bool</code></dt>
<dd>If this is True then if the indicator is False then we do not include.
If this is False then we always include the interaction</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of cids</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_adjacent(self, cid: int, incoming: bool, outgoing: bool, 
    use_indicators: bool=True) -&gt; Iterator[int]:
    &#39;&#39;&#39;Get all of the cluster IDs that have a positive interaction going into
    or from the cluster `cid`.

    Parameters
    ----------
    cid : int
        This is the Cluster ID you want to get the adjacent clusters of
    incoming : bool 
        Get the cids of the incoming edges
    outgoing : bool
        Get the cids of the outgoing edges
    use_indicators : bool
        If this is True then if the indicator is False then we do not include.
        If this is False then we always include the interaction

    Returns
    -------
    list
        List of cids
    &#39;&#39;&#39;
    if cid not in self.clustering.order:
        raise ValueError(&#39;`cid` ({}) not found&#39;.format(cid))
    cids = []
    if incoming:
        for interaction in self.iter_from_source(cid):
            if interaction.indicator or not use_indicators:
                cids.append(interaction.target_cid)
    if outgoing:
        for interaction in self.iter_to_target(cid):
            if interaction.indicator or not use_indicators:
                cids.append(interaction.source_cid)
    return cids</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.get_arg_indicators"><code class="name flex">
<span>def <span class="ident">get_arg_indicators</span></span>(<span>self, target_cid:Â intÂ =Â None, source_cid:Â intÂ =Â None) â€‘>Â Iterator[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the positive indicators as indices, in order -&gt; same convention
as <code>get_indicators</code>.</p>
<p>If <code>target_cid</code> is specfied, it will get all of the positive indicator indicies
going to the target cluster <code>target_cid</code> in order. If <code>source_cid</code> is specified,
then it will get all of the positive indicator indices going to the source cluster
<code>source_cid</code> in order. If both <code>target_cid</code> and <code>source_cid</code> are specified,
it will return an empty array if the indicator is False or it will return
an array of size 1 if the indicator is True.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target_cid</code></strong>, <strong><code>source_cid</code></strong> :&ensp;<code>int, None</code></dt>
<dd>These are the target cluster ID and source cluster ID, respectively.
If None then nothing is specified.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list(int)</code></dt>
<dd>Returns a list of the interactions that are positive in order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_arg_indicators(self, target_cid: int=None, source_cid: int=None) -&gt; Iterator[int]:
    &#39;&#39;&#39;Get the positive indicators as indices, in order -&gt; same convention
    as `get_indicators`.

    If `target_cid` is specfied, it will get all of the positive indicator indicies 
    going to the target cluster `target_cid` in order. If `source_cid` is specified,
    then it will get all of the positive indicator indices going to the source cluster 
    `source_cid` in order. If both `target_cid` and `source_cid` are specified,
    it will return an empty array if the indicator is False or it will return
    an array of size 1 if the indicator is True.

    Parameters
    ----------
    target_cid, source_cid : int, None
        These are the target cluster ID and source cluster ID, respectively.
        If None then nothing is specified.

    Returns
    -------
    list(int)
        Returns a list of the interactions that are positive in order
    &#39;&#39;&#39;
    ret = []
    try:
        if target_cid is not None:
            n_clusters = len(self.clustering)
            tcidx = self.clustering.cid2cidx[target_cid]

            if source_cid is not None:
                if self.value[target_cid][source_cid].indicator:
                    scidx = self.clustering.cid2cidx[source_cid]
                    if tcidx &lt; scidx:
                        scidx -= 1
                    iidx = tcidx * (n_clusters - 1) + scidx
                    ret.append(iidx)
            else:
                base_idx = tcidx * (n_clusters - 1)
                for offset, interaction in enumerate(self.iter_to_target(target_cid)):
                    if interaction.indicator:
                        ret.append(base_idx + offset)
        
        elif source_cid is not None:
            # We do not need to check if target_cid is not None because 
            # it would have been covered in the previous check
            scidx = self.clustering.cid2cidx[source_cid]
            for interaction in self.iter_from_source(source_cid):
                if interaction.indicator:
                    tcidx = self.clustering.cid2cidx[interaction.target_cid]

                    iidx = tcidx * (n_clusters - 1) + scidx
                    if scidx &gt; tcidx:
                        iidx -= 1
                    ret.append(iidx)

        else:
            for idx, interaction in enumerate(self):
                if interaction.indicator:
                    ret.append(idx)
        return ret
    except:
        # Check to see if it is a key error, else it is something weird
        if target_cid is not None or source_cid is not None:
            if not util.isint(target_cid) or not util.isint(source_cid):
                raise TypeError(&#39;`Either `target_cid` ({}) or `source_cid` ({})&#39; \
                    &#39; must be an int&#39;.format(type(target_cid), type(source_cid)))
            elif target_cid == source_cid:
                raise ValueError(&#39;`target_cid` ({}) and `source_cid` ({}) cannot&#39; \
                    &#39; be the same&#39;.format(target_cid, source_cid))
        raise</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.get_datalevel_indicator_matrix"><code class="name flex">
<span>def <span class="ident">get_datalevel_indicator_matrix</span></span>(<span>self) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Get the item-item indicator matrix.</p>
<p>The ordering of the items are the same as the order in
self.clusters.items.ids.order</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n,n), dtype=float)</code></dt>
<dd>This is the item-item interaction value matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datalevel_indicator_matrix(self) -&gt; np.ndarray:
    &#39;&#39;&#39;Get the item-item indicator matrix.

    The ordering of the items are the same as the order in
    self.clusters.items.ids.order

    Returns
    -------
    np.ndarray((n,n), dtype=float)
        This is the item-item interaction value matrix
    &#39;&#39;&#39;
    n_items = len(self.clustering.items)
    ret = np.zeros(shape=(n_items, n_items), dtype=bool)
    for interaction in self:
        if not interaction.indicator:
            continue
        for tidx in self.clustering.clusters[interaction.target_cid].members:
            for sidx in self.clustering.clusters[interaction.source_cid].members:
                ret[tidx, sidx] = True
    return ret</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.get_datalevel_value_matrix"><code class="name flex">
<span>def <span class="ident">get_datalevel_value_matrix</span></span>(<span>self, set_neg_indicators_to_nan:Â boolÂ =Â False) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Get the interaction matrix at the data level (item-item), not
at the cluster level. The ordering of the items is the same as
it is in the items in clustering (self.clustering.times).</p>
<p>If <code>set_neg_indicators_to_nan</code> is True, interactions that have a negative
indicator are set to np.nan. Else, they are set to 0.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_neg_indicators_to_nan</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, it will set the negative interaction indicator values to
np.nan. Else, it will set them to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n,n), dtype=float)</code></dt>
<dd>This is the item-item interaction value matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datalevel_value_matrix(self, set_neg_indicators_to_nan: bool=False) -&gt; np.ndarray:
    &#39;&#39;&#39;Get the interaction matrix at the data level (item-item), not
    at the cluster level. The ordering of the items is the same as 
    it is in the items in clustering (self.clustering.times).

    If `set_neg_indicators_to_nan` is True, interactions that have a negative
    indicator are set to np.nan. Else, they are set to 0.

    Parameters
    ----------
    set_neg_indicators_to_nan : bool
        If True, it will set the negative interaction indicator values to 
        np.nan. Else, it will set them to 0.

    Returns
    -------
    np.ndarray((n,n), dtype=float)
        This is the item-item interaction value matrix
    &#39;&#39;&#39;
    n_items = len(self.clustering.items)
    if set_neg_indicators_to_nan:
        fill = np.nan
    else:
        fill = 0
    ret = np.full(shape=(n_items, n_items), fill_value=fill, dtype=float)
    for interaction in self:
        if not interaction.indicator:
            continue
        val = interaction.value
        for tidx in self.clustering.clusters[interaction.target_cid].members:
            for sidx in self.clustering.clusters[interaction.source_cid].members:
                ret[tidx, sidx] = val
    return ret</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.get_indicators"><code class="name flex">
<span>def <span class="ident">get_indicators</span></span>(<span>self, target_cid:Â intÂ =Â None, source_cid:Â intÂ =Â None, return_idxs:Â boolÂ =Â False) â€‘>Â Iterator[bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a the indicator variables as a vector in the order specified
by the clusters.</p>
<p>if <code>target_cid</code> is specified then it will return all indicators going
to that cluster. If <code>source_cid</code> is specified then it will return all
indicators going from that cluster. If both are specifeid then it
will return an array of size 1 of a bool</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target_cid</code></strong>, <strong><code>source_cid</code></strong> :&ensp;<code>int, None</code></dt>
<dd>These are the target cluster ID and source cluster ID, respectively.
If None then nothing is specified.</dd>
<dt><strong><code>return_idxs</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, we return the index of the positive indicators. If False we
return an array of the indicator flags for every interaction. Nothing
is done if both <code>target_cid</code> and <code>source_cid</code> are specified</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray(n, dtype=bool)</code></dt>
<dd>Returns a bool vector of the indicators in roder</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_indicators(self, target_cid: int=None, source_cid: int=None,
    return_idxs: bool=False) -&gt; Iterator[bool]:
    &#39;&#39;&#39;Return a the indicator variables as a vector in the order specified
    by the clusters.

    if `target_cid` is specified then it will return all indicators going
    to that cluster. If `source_cid` is specified then it will return all
    indicators going from that cluster. If both are specifeid then it
    will return an array of size 1 of a bool

    Parameters
    ----------
    target_cid, source_cid : int, None
        These are the target cluster ID and source cluster ID, respectively.
        If None then nothing is specified.
    return_idxs : bool
        If True, we return the index of the positive indicators. If False we 
        return an array of the indicator flags for every interaction. Nothing
        is done if both `target_cid` and `source_cid` are specified

    Returns
    -------
    np.ndarray(n, dtype=bool)
        Returns a bool vector of the indicators in roder
    &#39;&#39;&#39;
    if target_cid is not None or source_cid is not None and return_idxs:
        mapping = {}
        order = self.clustering.order
        i = 0
        for tcid in order:
            for scid in order:
                if tcid == scid:
                    continue
                mapping[(tcid, scid)] = i
                i += 1
        
    try:
        if target_cid is not None:
            if source_cid is not None:
                ret = np.asarray([self.value[target_cid][source_cid].indicator])
            else:
                if return_idxs:
                    ret = []
                else:
                    l = len(self.clustering) - 1
                    ret = np.zeros(l, dtype=bool)
                for iidx, interaction in enumerate(self.iter_to_target(target_cid)):
                    if interaction.indicator:
                        if return_idxs:
                            ret.append(mapping[(target_cid, interaction.source_cid)])
                        else:
                            ret[iidx] = True
        elif source_cid is not None:
            # We do not need to check if target_cid is not None because 
            # it would have been covered in the previous check
            if return_idxs:
                ret = []
            else:
                l = len(self.clustering) - 1
                ret = np.zeros(l, dtype=bool)
            for iidx, interaction in enumerate(self.iter_from_source(source_cid)):
                if interaction.indicator:
                    if return_idxs:
                        ret.append(mapping[(interaction.target_cid, source_cid)])
                    else:
                        ret[iidx] = True

        else:
            if return_idxs:
                ret = []
            else:
                ret = np.zeros(self.size, dtype=bool)
            for idx, interaction in enumerate(self):
                if interaction.indicator:
                    if return_idxs:
                        ret.append(idx)
                    else:
                        ret[idx] = True
            return ret
        if return_idxs:
            ret = np.asarray(ret, dtpye=int)
        return ret

    except:
        # Check to see if it is a key error, else it is something weird
        if target_cid is not None or source_cid is not None:
            if not util.isint(target_cid) or not util.isint(source_cid):
                raise TypeError(&#39;`Either `target_cid` ({}) or `source_cid` ({})&#39; \
                    &#39; must be an int&#39;.format(type(target_cid), type(source_cid)))
            elif target_cid == source_cid:
                raise ValueError(&#39;`target_cid` ({}) and `source_cid` ({}) cannot&#39; \
                    &#39; be the same&#39;.format(target_cid, source_cid))
        raise</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.get_value_matrix"><code class="name flex">
<span>def <span class="ident">get_value_matrix</span></span>(<span>self, set_neg_indicators_to_nan:Â boolÂ =Â False) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Get the interaction matrix at the clustert level (item-item).
The ordering of the clusters is the same as it is in clustering</p>
<p>If <code>set_neg_indicators_to_nan</code> is True, interactions that have a negative
indicator are set to np.nan. Else, they are set to 0.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_neg_indicators_to_nan</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, it will set the negative interaction indicator values to
np.nan. Else, it will set them to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n,n), dtype=float)</code></dt>
<dd>This is the item-item interaction value matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_matrix(self, set_neg_indicators_to_nan: bool=False) -&gt; np.ndarray:
    &#39;&#39;&#39;Get the interaction matrix at the clustert level (item-item). 
    The ordering of the clusters is the same as it is in clustering

    If `set_neg_indicators_to_nan` is True, interactions that have a negative
    indicator are set to np.nan. Else, they are set to 0.

    Parameters
    ----------
    set_neg_indicators_to_nan : bool
        If True, it will set the negative interaction indicator values to 
        np.nan. Else, it will set them to 0.

    Returns
    -------
    np.ndarray((n,n), dtype=float)
        This is the item-item interaction value matrix
    &#39;&#39;&#39;
    n_clusters = len(self.clustering)
    if set_neg_indicators_to_nan:
        fill = np.nan
    else:
        fill = 0
    ret = np.full(shape=(n_clusters, n_clusters), fill_value=fill, dtype=float)
    for interaction in self:
        if not interaction.indicator:
            continue
        tcidx = self.clustering.cid2cidx[interaction.target_cid]
        scidx = self.clustering.cid2cidx[interaction.source_cid]
        ret[tcidx, scidx] = interaction.value
    return ret</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.get_values"><code class="name flex">
<span>def <span class="ident">get_values</span></span>(<span>self, use_indicators:Â boolÂ =Â True) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a vector of the interaction variables in the order of the
clustering</p>
<p>if use_indicators is True, it skips over the indices that have a negative
indicator variable. if it is True, it goes over everthing</p>
<h2 id="paramters">Paramters</h2>
<p>use_indicators : bool, Optional
If True, we only return the interactions with a positive indicator. Else we get every
single interaction</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray(n, dtype=float)</code></dt>
<dd>Array of the interaction values, in order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_values(self, use_indicators: bool=True) -&gt; np.ndarray:
    &#39;&#39;&#39;Makes a vector of the interaction variables in the order of the
    clustering

    if use_indicators is True, it skips over the indices that have a negative
    indicator variable. if it is True, it goes over everthing

     Paramters
    ---------
    use_indicators : bool, Optional
        If True, we only return the interactions with a positive indicator. Else we get every
        single interaction

    Returns
    -------
    np.ndarray(n, dtype=float)
        Array of the interaction values, in order
    &#39;&#39;&#39;
    ret = np.zeros(self.size)
    idx = 0
    if use_indicators:
        for interaction in self.iter_valid():
            ret[idx] = interaction.value
            idx += 1
    else:
        for interaction in self:
            ret[idx] = interaction.value
            idx += 1
    # Trim if necessary
    return ret[:idx]</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.iloc"><code class="name flex">
<span>def <span class="ident">iloc</span></span>(<span>self, idx:Â int) â€‘>Â mdsine2.pylab.contrib._Interaction</span>
</code></dt>
<dd>
<div class="desc"><p>Get the interaction as a function of the index that it occurs at.
Reverse indexing is allowed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>This is the index that the interaction occurs at</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pylab.contrib._Interaction</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iloc(self, idx: int) -&gt; &#34;_Interaction&#34;:
    &#39;&#39;&#39;Get the interaction as a function of the index that it occurs at.
    Reverse indexing is allowed.

    Parameters
    ----------
    idx : int
        This is the index that the interaction occurs at

    Returns
    -------
    pylab.contrib._Interaction
    &#39;&#39;&#39;
    if not util.isint(idx):
        raise TypeError(&#39;`idx` ({}) must be an int&#39;.format(idx))
    if idx &gt;= self.size:
        raise ValueError(&#39;`idx` ({}) cannot be &gt;= the number of interactions ({})&#39;.format(
            idx, self.size))
    if idx &lt; 0:
        idx = self.size - idx
    tcidx = idx // (len(self.clustering) - 1)
    scidx = idx - tcidx * (len(self.clustering) - 1)
    if scidx &gt;= tcidx:
        scidx += 1
    return self.value[
        self.clustering.order[tcidx]][
        self.clustering.order[scidx]]</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.iter_from_source"><code class="name flex">
<span>def <span class="ident">iter_from_source</span></span>(<span>self, cid:Â int, only_valid:Â boolÂ =Â False) â€‘>Â mdsine2.pylab.contrib._Interaction</span>
</code></dt>
<dd>
<div class="desc"><p>Iterates over interactions from the source cluster to all
target clusters in the order specified by clusters</p>
<h2 id="paramters">Paramters</h2>
<p>cid (int)
This is the source cluster id
only_valid : bool
If True, only returns the interactions with a positive indicator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_from_source(self, cid: int, only_valid: bool=False) -&gt; &#34;_Interaction&#34;:
    &#39;&#39;&#39;Iterates over interactions from the source cluster to all
    target clusters in the order specified by clusters

    Paramters
    ---------
    cid (int)
        This is the source cluster id
    only_valid : bool
        If True, only returns the interactions with a positive indicator
    &#39;&#39;&#39;
    order = self.clustering.order
    if only_valid:
        for tcid in order:
            if tcid != cid:
                if self.value[tcid][cid].indicator:
                    yield self.value[tcid][cid]
    else:
        for tcid in order:
            if tcid != cid:
                yield self.value[tcid][cid]</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.iter_to_target"><code class="name flex">
<span>def <span class="ident">iter_to_target</span></span>(<span>self, cid:Â int, only_valid:Â boolÂ =Â False) â€‘>Â mdsine2.pylab.contrib._Interaction</span>
</code></dt>
<dd>
<div class="desc"><p>Iterates over interactions to the target cluster from all
source clusters in the order specified by clusters</p>
<h2 id="paramters">Paramters</h2>
<p>cid : int
This is the target cluster id we are iterating from
only_valid : bool
If True, only returns the interactions with a positive indicator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_to_target(self, cid: int, only_valid: bool=False) -&gt; &#34;_Interaction&#34;:
    &#39;&#39;&#39;Iterates over interactions to the target cluster from all
    source clusters in the order specified by clusters

    Paramters
    ---------
    cid : int
        This is the target cluster id we are iterating from
    only_valid : bool
        If True, only returns the interactions with a positive indicator
    &#39;&#39;&#39;
    order = self.clustering.order
    temp = self.value[cid] # For quicker pointer
    if only_valid:
        for scid in order:
            if scid != cid:
                if temp[scid].indicator:
                    yield temp[scid]
    else:
        for scid in order:
            if scid != cid:
                yield temp[scid]</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.iter_valid"><code class="name flex">
<span>def <span class="ident">iter_valid</span></span>(<span>self) â€‘>Â mdsine2.pylab.contrib._Interaction</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate only over the positive indicators</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_valid(self) -&gt; &#34;_Interaction&#34;:
    &#39;&#39;&#39;Iterate only over the positive indicators
    &#39;&#39;&#39;
    order = self.clustering.order
    for tcid in order:
        temp = self.value[tcid] # Faster pointer
        for scid in order:
            if tcid != scid:
                if temp[scid].indicator:
                    yield temp[scid]</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.iter_valid_pairs"><code class="name flex">
<span>def <span class="ident">iter_valid_pairs</span></span>(<span>self) â€‘>Â Tuple[int,Â int]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate only over the positive indicators</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_valid_pairs(self) -&gt; Tuple[int, int]:
    &#39;&#39;&#39;Iterate only over the positive indicators
    &#39;&#39;&#39;
    order = self.clustering.order
    for tcid in order:
        temp = self.value[tcid] # Faster pointer
        for scid in order:
            if tcid != scid:
                if temp[scid].indicator:
                    yield tcid, scid</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.key_pairs"><code class="name flex">
<span>def <span class="ident">key_pairs</span></span>(<span>self, only_valid:Â boolÂ =Â False) â€‘>Â Iterator[Tuple[int,Â int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns (target,source) cluster ids in order</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>only_valid</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, it will only return the key pairs that have a positive indicator.
Else it will return all of the interactions regardless of the indicator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list((int,int))
Return a list of the (target, source) cluster IDs for each interaciton
in order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_pairs(self, only_valid: bool=False) -&gt; Iterator[Tuple[int, int]]:
    &#39;&#39;&#39;Returns (target,source) cluster ids in order

    Parameters
    ----------
    only_valid : bool
        If True, it will only return the key pairs that have a positive indicator.
        Else it will return all of the interactions regardless of the indicator.

    Returns 
    -------
    list((int,int))
        Return a list of the (target, source) cluster IDs for each interaciton
        in order.
    &#39;&#39;&#39;
    order = self.clustering.order
    l = []
    for tcid in order:
        for scid in order:
            if tcid != scid:
                if only_valid:
                    if self.value[tcid][scid].indicator:
                        l.append((tcid, scid))
                else:
                    l.append((tcid,scid))
    return l</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.num_neg_indicators"><code class="name flex">
<span>def <span class="ident">num_neg_indicators</span></span>(<span>self, target_cid:Â intÂ =Â None) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of indicator variables that are 0</p>
<p>If target_cid is not None, calculate them for only the interactions going into
that cluster</p>
<h2 id="paramters">Paramters</h2>
<p>target_cid : int, Optional
If this is specified, get only the negative indicators going into the cluster
<code>target_cid</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_neg_indicators(self, target_cid: int=None) -&gt; int:
    &#39;&#39;&#39;Return the number of indicator variables that are 0

    If target_cid is not None, calculate them for only the interactions going into
    that cluster

    Paramters
    ---------
    target_cid : int, Optional
        If this is specified, get only the negative indicators going into the cluster 
        `target_cid`
    &#39;&#39;&#39;
    cumm = 0
    if target_cid is not None:
        for interaction in self.iter_to_target(target_cid):
            cumm += not interaction.indicator
    else:
        for interaction in self:
            cumm += not interaction.indicator
    return cumm</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.num_pos_indicators"><code class="name flex">
<span>def <span class="ident">num_pos_indicators</span></span>(<span>self, target_cid:Â intÂ =Â None) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of indicator variables that are 1</p>
<p>If target_cid is not None, calculate them for only the interactions going into
that cluster</p>
<h2 id="paramters">Paramters</h2>
<p>target_cid : int, Optional
If this is specified, get only the positive indicators going into the cluster
<code>target_cid</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_pos_indicators(self, target_cid: int=None) -&gt; int:
    &#39;&#39;&#39;Return the number of indicator variables that are 1

    If target_cid is not None, calculate them for only the interactions going into
    that cluster

    Paramters
    ---------
    target_cid : int, Optional
        If this is specified, get only the positive indicators going into the cluster 
        `target_cid`
    &#39;&#39;&#39;
    cumm = 0
    if target_cid is not None:
        for interaction in self.iter_to_target(target_cid):
            cumm += interaction.indicator
    else:
        for interaction in self:
            cumm += interaction.indicator
    return cumm</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.remove_local_trace"><code class="name flex">
<span>def <span class="ident">remove_local_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the local trace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_local_trace(self):
    &#39;&#39;&#39;Delete the local trace
    &#39;&#39;&#39;
    self.trace = None</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset all of the interactions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#39;&#39;&#39;Reset all of the interactions
    &#39;&#39;&#39;
    self.value = {}
    for tcid in self.clustering.order:
        self.value[tcid] = {}
        for scid in self.clustering.order:
            if tcid == scid:
                continue
            self.value[tcid][scid] = _Interaction(
                source_cid=scid, target_cid=tcid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer()&gt;=.5, 
                iden=self._IIDX)
            self._IIDX += 1</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.set_indicators"><code class="name flex">
<span>def <span class="ident">set_indicators</span></span>(<span>self, arr:Â numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the values of the indicators of the interactions from a vector.</p>
<p>If <code>include_self_interactions</code> is True, assumes that <code>arr</code> contains the
values for the self interactions. If False, assume that the indices are
skipped.</p>
<h2 id="paramters">Paramters</h2>
<p>arr : np.ndarray(n, dtpye=bool)
These are the indicator values to set, in order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_indicators(self, arr: np.ndarray):
    &#39;&#39;&#39;Sets the values of the indicators of the interactions from a vector.

    If `include_self_interactions` is True, assumes that `arr` contains the
    values for the self interactions. If False, assume that the indices are
    skipped.

    Paramters
    ---------
    arr : np.ndarray(n, dtpye=bool)
        These are the indicator values to set, in order
    &#39;&#39;&#39;
    if len(arr) != self.size:
        raise ValueError(&#39;The number of elements in `arr` ({}) is not the &#39; \
            &#39;same as the number of interactions ({})&#39;.format(len(arr), self.size))
    for idx, interaction in enumerate(self):
        interaction.indicator = arr[idx]
        if interaction.indicator == 0:
            interaction.value = 0</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Interactions.set_values"><code class="name flex">
<span>def <span class="ident">set_values</span></span>(<span>self, arr:Â numpy.ndarray, use_indicators:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the values of the interactions from a vector.</p>
<p>If <code>use_indicators</code> is True, assumes that the values in the vector only contain
values for interactions where the indicator variable is positive and the
rest are skipped. If False, assumes the vector has values for where the
indicator variables are positive and negative (all).</p>
<h2 id="paramters">Paramters</h2>
<p>arr : np.ndarray(n, dtpye=float)
These are the interaction values to set, in order
use_indicators : bool, Optional
If True, we only set the interactions with a positive indicator. Else we set every
single interaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_values(self, arr: np.ndarray, use_indicators: bool=True):
    &#39;&#39;&#39;Sets the values of the interactions from a vector.

    If `use_indicators` is True, assumes that the values in the vector only contain
    values for interactions where the indicator variable is positive and the
    rest are skipped. If False, assumes the vector has values for where the
    indicator variables are positive and negative (all).

    Paramters
    ---------
    arr : np.ndarray(n, dtpye=float)
        These are the interaction values to set, in order
    use_indicators : bool, Optional
        If True, we only set the interactions with a positive indicator. Else we set every
        single interaction
    &#39;&#39;&#39;
    if not use_indicators:
        if len(arr) != self.size:
            raise ValueError(&#39;The number of elements in `arr` ({}) is not the &#39; \
                &#39;same as the number of interactions ({})&#39;.format(len(arr), self.size))
        for idx, interaction in enumerate(self):
            interaction.value = arr[idx]
    else:
        # Dont check because it is too computationally intensive
        idx = 0
        for interaction in self:
            if not interaction.indicator:
                continue
            interaction.value = arr[idx]
            idx += 1</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.cluster.ClusterProperty" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty">ClusterProperty</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.assignments_changed" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty.assignments_changed">assignments_changed</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.set_signal_when_clusters_change" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_clusters_change">set_signal_when_clusters_change</a></code></li>
<li><code><a title="mdsine2.pylab.cluster.ClusterProperty.set_signal_when_item_assignment_changes" href="cluster.html#mdsine2.pylab.cluster.ClusterProperty.set_signal_when_item_assignment_changes">set_signal_when_item_assignment_changes</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.graph.Node.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.base.Traceable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.base.Traceable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.contrib.Perturbation"><code class="flex name class">
<span>class <span class="ident">Perturbation</span></span>
<span>(</span><span>taxa:Â <a title="mdsine2.pylab.base.TaxaSet" href="base.html#mdsine2.pylab.base.TaxaSet">TaxaSet</a>, starts:Â Dict[str,Â float], ends:Â Dict[str,Â float], magnitude:Â Union[<a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a>,Â numpy.ndarray,Â int,Â float]Â =Â None, indicator:Â Union[<a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a>,Â numpy.ndarray]Â =Â None, probability:Â Union[<a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a>,Â float]Â =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an implementation of a perturbation where the
values <em>DO NOT</em> depend on clusters.</p>
<p>If you want to compute the bayes factors for each item, you can
calculate ~np.isnan for the trace. This will give an indicator
array that you can then use to calculate the bayes factor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>starts</code></strong>, <strong><code>ends</code></strong> :&ensp;<code>dict</code></dt>
<dd>Start and end of the perturbation for each subject</dd>
<dt><strong><code>taxa</code></strong> :&ensp;<code>pylab.base.TaxaSet</code></dt>
<dd>Set of taxon/otu objects</dd>
<dt><strong><code>magnitude</code></strong> :&ensp;<code>pylab.variables.Variable, int/float, array, Optional</code></dt>
<dd>If a pylab.variables.Variable is passed in it will create one
with the value indicated. Defualt value is None</dd>
<dt><strong><code>indicator</code></strong> :&ensp;<code>pylab.variables.Variable, array, Optional</code></dt>
<dd>This is the indicator of the perturbation. Default value is False
for every taxon</dd>
<dt><strong><code>probability</code></strong> :&ensp;<code>pylab.variables.Variable, float, Optional</code></dt>
<dd>This is the probability that the perturbation affects a taxon, e.g.
probability = 0.7, there's a 70% chance that the perturbation afffects
each taxon</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<ul>
<li>Extra arguments for the Node class</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Perturbation(BasePerturbation, variables.Variable):
    &#39;&#39;&#39;This is an implementation of a perturbation where the 
    values *DO NOT* depend on clusters.

    If you want to compute the bayes factors for each item, you can 
    calculate ~np.isnan for the trace. This will give an indicator 
    array that you can then use to calculate the bayes factor.

    Parameters
    ----------
    starts, ends : dict
        Start and end of the perturbation for each subject
    taxa : pylab.base.TaxaSet
        Set of taxon/otu objects
    magnitude : pylab.variables.Variable, int/float, array, Optional
        If a pylab.variables.Variable is passed in it will create one
        with the value indicated. Defualt value is None
    indicator : pylab.variables.Variable, array, Optional
        This is the indicator of the perturbation. Default value is False 
        for every taxon
    probability : pylab.variables.Variable, float, Optional
        This is the probability that the perturbation affects a taxon, e.g.
          probability = 0.7, there&#39;s a 70% chance that the perturbation afffects 
          each taxon
    kwargs : dict
        - Extra arguments for the Node class
    &#39;&#39;&#39;
    def __init__(self, taxa: base.TaxaSet, starts: Dict[str, float], ends: Dict[str, float], 
        magnitude: Union[variables.Variable, np.ndarray, int, float]=None, 
        indicator: Union[variables.Variable, np.ndarray]=None, 
        probability: Union[variables.Variable, float]=None, **kwargs):
        
        variables.Variable.__init__(self, **kwargs)
        if self.G.perturbations is None:
            self.G.perturbations = PerturbationSet()
        BasePerturbation.__init__(self, starts=starts, ends=ends, name=self.name)
        
        if not base.istaxaset(taxa):
            raise TypeError(&#39;`taxa` ({}) must be pylab.base.TaxaSet&#39;.format(type(taxa)))

        self.G.perturbations.append(self)
        self.taxa = taxa
        n_taxa = len(self.taxa)
        self.set_value_shape(shape=(n_taxa, )) # Set the shape of the internal array

        # Set magnitude
        if magnitude is None:
            magnitude = np.full(n_taxa, 0)
        if util.isnumeric(magnitude):
            magnitude = np.full(n_taxa, magnitude)
        if util.isarray(magnitude):
            if len(magnitude) != n_taxa:
                raise ValueError(&#39;`magnitue` ({}) must have length {}&#39;.format(
                    len(magnitude), n_taxa))
            magnitude = variables.Variable(
                G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX, 
                value=magnitude)
            magnitude.set_value_shape((n_taxa,))
        elif variables.isVariable(magnitude):
            if len(magnitude) != n_taxa:
                raise ValueError(&#39;`magnitue` ({}) must have length {}&#39;.format(magnitude, n_taxa))
        else:
            raise TypeError(&#39;`magnitude` ({}) type not recognized&#39;.format(type(magnitude)))
              
        # Set probability
        if not variables.isVariable(probability):
            if not util.isfloat(probability) and probability is not None:
                raise ValueError(&#39;`probability` ({}) must be a pylab.variables.Variable&#39; \
                    &#39;, a float, or None&#39;.format(type(probability)))
            if util.isfloat(probability):
                if probability &lt; 0 or probability &gt; 1:
                    raise ValueError(&#39;`probability` ({}) must be in [0,1]&#39;.format(
                        probability))
            probability = variables.Variable(value=probability, G=self.G, dtype=float,
                name=self.name+DEFAULT_PROBABILITY_SUFFIX)

        # Set indicator
        if indicator is None:
            indicator = np.full(n_taxa, False, dtype=bool)
        if util.isbool(indicator):
            indicator = np.full(n_taxa, indicator, dtype=bool)
        if util.isarray(indicator):
            if len(indicator) != n_taxa:
                raise ValueError(&#39;`indicator` ({}) must have length {}&#39;.format(
                    len(indicator), n_taxa))
            indicator = variables.Variable(
                G=self.G, dtype=bool, name=self.name+DEFAULT_INDICATOR_SUFFIX, 
                value=indicator)
            indicator.set_value_shape((n_taxa,))
        elif variables.isVariable(indicator):
            if len(indicator) != n_taxa:
                raise ValueError(&#39;`magnitue` ({}) must have length {}&#39;.format(indicator, n_taxa))
        else:
            raise TypeError(&#39;`indicator` ({}) type not recognized&#39;.format(type(indicator)))

        self.magnitude = magnitude # Variable
        self.indicator = indicator # Variable
        self.probability = probability # Variable

    def __str__(self) -&gt; str:
        s = BasePerturbation.__str__(self)
        s += &#39;\nMagnitude:\n&#39;
        for oidx in range(len(self.taxa)):
            s += &#39;\t{}: {}\n&#39;.format(oidx, self.magnitude.value[oidx])
        s += &#39;Indicator:\n&#39;
        for oidx in range(len(self.taxa)):
            s += &#39;\t{}: {}\n&#39;.format(oidx, self.indicator.value[oidx])
        s += &#39;Probability: {}&#39;.format(self.probability.value)
        return s

    def add_trace(self):
        &#39;&#39;&#39;Set the negative indicators as np.nan
        &#39;&#39;&#39;
        self.value = np.full(len(self.taxa), np.nan)
        ind = self.indicator.value
        self.value[ind] = self.magnitude.value[ind]
        variables.Variable.add_trace(self)

    def remove_local_trace(self):
        &#39;&#39;&#39;Delete the local trace
        &#39;&#39;&#39;
        self.trace = None

    def array(self, only_pos_ind: bool=False) -&gt; np.ndarray:
        &#39;&#39;&#39;Return the magnitudes with the indicatrs indexed out

        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        &#39;&#39;&#39;
        ind = self.indicator.value
        if only_pos_ind:
            val = self.magnitude.value[ind]
        else:
            val = np.zeros(len(self.taxa))
            val[ind] = self.magnitude.value[ind]
        return val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.base.BasePerturbation" href="base.html#mdsine2.pylab.base.BasePerturbation">BasePerturbation</a></li>
<li><a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.contrib.Perturbation.add_trace"><code class="name flex">
<span>def <span class="ident">add_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the negative indicators as np.nan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_trace(self):
    &#39;&#39;&#39;Set the negative indicators as np.nan
    &#39;&#39;&#39;
    self.value = np.full(len(self.taxa), np.nan)
    ind = self.indicator.value
    self.value[ind] = self.magnitude.value[ind]
    variables.Variable.add_trace(self)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Perturbation.array"><code class="name flex">
<span>def <span class="ident">array</span></span>(<span>self, only_pos_ind:Â boolÂ =Â False) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the magnitudes with the indicatrs indexed out</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>only_pos_ind</code></strong> :&ensp;<code>bool</code></dt>
<dd>If this is True, then it will return only for when the indicator is positive</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray((n_c,), dtype=float)</code></dt>
<dd>Array of the cluster perturbation values for each cluster</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def array(self, only_pos_ind: bool=False) -&gt; np.ndarray:
    &#39;&#39;&#39;Return the magnitudes with the indicatrs indexed out

    Parameters
    ----------
    only_pos_ind : bool
        If this is True, then it will return only for when the indicator is positive

    Returns
    -------
    np.ndarray((n_c,), dtype=float)
        Array of the cluster perturbation values for each cluster
    &#39;&#39;&#39;
    ind = self.indicator.value
    if only_pos_ind:
        val = self.magnitude.value[ind]
    else:
        val = np.zeros(len(self.taxa))
        val[ind] = self.magnitude.value[ind]
    return val</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.contrib.Perturbation.remove_local_trace"><code class="name flex">
<span>def <span class="ident">remove_local_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the local trace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_local_trace(self):
    &#39;&#39;&#39;Delete the local trace
    &#39;&#39;&#39;
    self.trace = None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.base.BasePerturbation" href="base.html#mdsine2.pylab.base.BasePerturbation">BasePerturbation</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.base.BasePerturbation.isactive" href="base.html#mdsine2.pylab.base.BasePerturbation.isactive">isactive</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="variables.html#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="variables.html#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="variables.html#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdsine2.pylab" href="index.html">mdsine2.pylab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mdsine2.pylab.contrib.isclusterperturbation" href="#mdsine2.pylab.contrib.isclusterperturbation">isclusterperturbation</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.isclusterperturbationindicator" href="#mdsine2.pylab.contrib.isclusterperturbationindicator">isclusterperturbationindicator</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.isinteractions" href="#mdsine2.pylab.contrib.isinteractions">isinteractions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdsine2.pylab.contrib.ClusterPerturbationEffect" href="#mdsine2.pylab.contrib.ClusterPerturbationEffect">ClusterPerturbationEffect</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationEffect.add_trace" href="#mdsine2.pylab.contrib.ClusterPerturbationEffect.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationEffect.cluster_array" href="#mdsine2.pylab.contrib.ClusterPerturbationEffect.cluster_array">cluster_array</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationEffect.item_array" href="#mdsine2.pylab.contrib.ClusterPerturbationEffect.item_array">item_array</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationEffect.remove_local_trace" href="#mdsine2.pylab.contrib.ClusterPerturbationEffect.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationEffect.set_values_from_array" href="#mdsine2.pylab.contrib.ClusterPerturbationEffect.set_values_from_array">set_values_from_array</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator">ClusterPerturbationIndicator</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.cluster_arg_array" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.cluster_arg_array">cluster_arg_array</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.cluster_bool_array" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.cluster_bool_array">cluster_bool_array</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.clusters_changed" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.clusters_changed">clusters_changed</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.get_clusters_on" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.get_clusters_on">get_clusters_on</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.get_items_on" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.get_items_on">get_items_on</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.item_arg_array" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.item_arg_array">item_arg_array</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.item_bool_array" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.item_bool_array">item_bool_array</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.num_on_clusters" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.num_on_clusters">num_on_clusters</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.num_on_items" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.num_on_items">num_on_items</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationIndicator.reset" href="#mdsine2.pylab.contrib.ClusterPerturbationIndicator.reset">reset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.contrib.ClusterPerturbationValue" href="#mdsine2.pylab.contrib.ClusterPerturbationValue">ClusterPerturbationValue</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationValue.clusters_changed" href="#mdsine2.pylab.contrib.ClusterPerturbationValue.clusters_changed">clusters_changed</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.ClusterPerturbationValue.reset" href="#mdsine2.pylab.contrib.ClusterPerturbationValue.reset">reset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.contrib.Interactions" href="#mdsine2.pylab.contrib.Interactions">Interactions</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.contrib.Interactions.clusters_changed" href="#mdsine2.pylab.contrib.Interactions.clusters_changed">clusters_changed</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.generate_in_out_degree_posthoc" href="#mdsine2.pylab.contrib.Interactions.generate_in_out_degree_posthoc">generate_in_out_degree_posthoc</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.get_adjacent" href="#mdsine2.pylab.contrib.Interactions.get_adjacent">get_adjacent</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.get_arg_indicators" href="#mdsine2.pylab.contrib.Interactions.get_arg_indicators">get_arg_indicators</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.get_datalevel_indicator_matrix" href="#mdsine2.pylab.contrib.Interactions.get_datalevel_indicator_matrix">get_datalevel_indicator_matrix</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.get_datalevel_value_matrix" href="#mdsine2.pylab.contrib.Interactions.get_datalevel_value_matrix">get_datalevel_value_matrix</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.get_indicators" href="#mdsine2.pylab.contrib.Interactions.get_indicators">get_indicators</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.get_value_matrix" href="#mdsine2.pylab.contrib.Interactions.get_value_matrix">get_value_matrix</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.get_values" href="#mdsine2.pylab.contrib.Interactions.get_values">get_values</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.iloc" href="#mdsine2.pylab.contrib.Interactions.iloc">iloc</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.iter_from_source" href="#mdsine2.pylab.contrib.Interactions.iter_from_source">iter_from_source</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.iter_to_target" href="#mdsine2.pylab.contrib.Interactions.iter_to_target">iter_to_target</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.iter_valid" href="#mdsine2.pylab.contrib.Interactions.iter_valid">iter_valid</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.iter_valid_pairs" href="#mdsine2.pylab.contrib.Interactions.iter_valid_pairs">iter_valid_pairs</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.key_pairs" href="#mdsine2.pylab.contrib.Interactions.key_pairs">key_pairs</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.num_neg_indicators" href="#mdsine2.pylab.contrib.Interactions.num_neg_indicators">num_neg_indicators</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.num_pos_indicators" href="#mdsine2.pylab.contrib.Interactions.num_pos_indicators">num_pos_indicators</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.remove_local_trace" href="#mdsine2.pylab.contrib.Interactions.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.reset" href="#mdsine2.pylab.contrib.Interactions.reset">reset</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.set_indicators" href="#mdsine2.pylab.contrib.Interactions.set_indicators">set_indicators</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.set_values" href="#mdsine2.pylab.contrib.Interactions.set_values">set_values</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Interactions.size" href="#mdsine2.pylab.contrib.Interactions.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.contrib.Perturbation" href="#mdsine2.pylab.contrib.Perturbation">Perturbation</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.contrib.Perturbation.add_trace" href="#mdsine2.pylab.contrib.Perturbation.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Perturbation.array" href="#mdsine2.pylab.contrib.Perturbation.array">array</a></code></li>
<li><code><a title="mdsine2.pylab.contrib.Perturbation.remove_local_trace" href="#mdsine2.pylab.contrib.Perturbation.remove_local_trace">remove_local_trace</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>