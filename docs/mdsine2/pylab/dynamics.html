<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mdsine2.pylab.dynamics API documentation</title>
<meta name="description" content="This module is for specifying dynamics. Additionally, we can integrate the
dynamics with the function `integrate` â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdsine2.pylab.dynamics</code></h1>
</header>
<section id="section-intro">
<p>This module is for specifying dynamics. Additionally, we can integrate the
dynamics with the function <code><a title="mdsine2.pylab.dynamics.integrate" href="#mdsine2.pylab.dynamics.integrate">integrate()</a></code>.</p>
<p>Changes to Make in pylab 1.0
- Fix Negative Binomial
- Type hinting - I think this should be super important
* mypy?
- Make Metropolis better
* look at implementation in posterior
- Distinguish between TypeError and ValueError in initializations
- Redo how you make the SubjsetSet - idk how but it's messy</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;This module is for specifying dynamics. Additionally, we can integrate the 
dynamics with the function `integrate`.

Changes to Make in pylab 1.0
    - Fix Negative Binomial
    - Type hinting - I think this should be super important
        * mypy?
    - Make Metropolis better
        * look at implementation in posterior
    - Distinguish between TypeError and ValueError in initializations
    - Redo how you make the SubjsetSet - idk how but it&#39;s messy
&#39;&#39;&#39;
import numpy as np
import numpy.random as npr
import sys
import time
import logging
import math

# Typing
from typing import TypeVar, Generic, Any, Union, Dict, Iterator, Tuple


from . import util as plu
from .errors import NeedToImplementError

_ADDITIVE = 0
_MULTIPLICATIVE = 1


def isdynamics(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks if `a` is a (subclass of) BaseDynamics

    Parameters
    ----------
    x : any
        Instance we are checking

    Returns
    -------
    bool
        True if `x` is a subclass of a BaseDynamics
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, BaseDynamics)

def isprocessvariance(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks if `a` is a (subclass of) ProcessVariance

    Parameters
    ----------
    x : any
        Instance we are checking

    Returns
    -------
    bool
        True if `x` is a subclass of a BaseProcessVariance
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, BaseProcessVariance)

def isintegratable(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks if `a` is a (subclass of) Integratable

    Parameters
    ----------
    x : any
        Instance we are checking

    Returns
    -------
    bool
        True if `x` is a subclass of a Integratable
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, Integratable)

class Integratable:
    &#39;&#39;&#39;These are the functions needed for integrating
    &#39;&#39;&#39;  
    def init_integration(self):
        &#39;&#39;&#39;This is the function that `integrate` calls to start the integration
        &#39;&#39;&#39;
        pass

    def integrate_single_timestep(self, x: np.ndarray, t: float, dt: float):
        &#39;&#39;&#39;This is the function that `integrate` calls to propagate the underlying
        dynamics a single time step. There is no type checking for computational
        efficiency

        Parameters
        ----------
        x : np.ndarray((n,1))
            This is the abundance as a column vector for each taxon
        t : numeric
            This is the time point we are integrating to
        dt : numeric
            This is the amount of time from the previous time point we
            are integrating from
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def finish_integration(self):
        &#39;&#39;&#39;This is the function that
        &#39;&#39;&#39;
        pass


class BaseDynamics(Integratable):
    &#39;&#39;&#39;This is the base class for the dynamics
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        Integratable.__init__(self, **kwargs)

    def stability(self):
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def integrate(self, *args, **kwargs):
        return integrate(dynamics=self, *args, **kwargs)


class BaseProcessVariance(Integratable):
    &#39;&#39;&#39;
    &#39;&#39;&#39;
    def __init__(self, *args, **kwargs):
        Integratable.__init__(self, *args, **kwargs)


class _NoProcessVariance(Integratable):
    &#39;&#39;&#39;This is when you do not want process variance during integration.
    For inner use only.
    &#39;&#39;&#39;
    def __init__(self, *args, **kwargs):
        Integratable.__init__(self, *args, **kwargs)

    def integrate_single_timestep(self, x: np.ndarray, *args, **kwargs):
        &#39;&#39;&#39;Do nothing
        &#39;&#39;&#39;
        return x


def integrate(dynamics: BaseDynamics, initial_conditions: np.ndarray, dt: float, n_days: float, 
    processvar: BaseProcessVariance=None, subsample: bool=False, times: np.ndarray=None, 
    log_every: int=10000) -&gt; Dict[str, np.ndarray]:
    &#39;&#39;&#39;Numerically integrates the ODE given the dynamics and the initial 
    conditions. If the process variance is not None, then this integrates
    a stochastic ODE.

    Subsampling
    -----------
    If the dynamics are complex and the process variance is high, numerical
    integration with large time steps can lead to numerical instability, so we 
    integrate at smaller time steps than what our data is. This smaller time
    scale in this function is specified by `dt`.

    We can then subsample our densely integrated trajectories with the flag
    `subsample`. If `subsample=False`, we return the whole trajectory. If
    `subsample` is True, then we must also specify `times`.

    Parameters
    ----------
    dynamics : BaseDynamics
        These are the dynamics that we want to integrate.
    processvar : BaseProcessVariance, None
        This is the process variance we want to inject into the integration.
        If None, we assume there is no process variance and it is a normal ODE
    initial_conditions : np.ndarray((n_taxa,1), dtype=float)
        These are the initial conditions to integrate from. This must be a 
        column array.
    dt : float
        Time between each time step (in days) during integration
    n_days : float
        How many days to simulate for
    subsample : bool
        If True, we subsample the integration at the time points indicated in
        `times`. If False we do not subsample
    times : int, np.ndarray((t,), dtype=numeric), None
        `times` must be a list of floats/ints, where each element 
        corresponds to a time of day to take the sample at. The last time 
        point must not exceed `n_days`, each time must be &gt;= 0, and there
        must not be duplicates.
        Example: (assuming `subsample` is True)
            n_days = 6
            times = [0, 0.1, 1.1, 3, 5] - This is valid
            times = [0.1, 0, 1.1, 3, 5] - This is valid:
                (0 is automatically reordered)
            times = [0, 0.1, 1.1, 3, 6] - This is invalid: 
                (6 is not inclusive)
            times = [-0.1, 0, 1.1, 3, 5] - This is invalid:
                (-0.1 &lt; 0)
            times = [0, 0, 1.1, 3, 5] - This is valid:
                (duplicate points for `0`, but we discard 1)

        If `subsample` is True and `times` is None, we automatically 
        return 1 timepoint per day.
    log_every : int, None
        - This is how oftent o log the progress of the integration. If None, it 
          will never log

    Returns
    -------
    dict
        &#39;X&#39;: np.ndarray((n_taxa, k), dtype=float)
            The abundances for each taxon (row) for each time (column)
        &#39;times&#39;: np.ndarray((k, ), dtype=float)
            These are the times, in days, for each column
    &#39;&#39;&#39;
    # Type and format checking
    if not isdynamics(dynamics):
        raise TypeError(&#39;`dynamics` ({}) must be a (subclass of) &#39; \
            &#39;BaseDynamics&#39;.format(type(dynamics)))

    if processvar is None:
        processvar = _NoProcessVariance()
    elif not isprocessvariance(processvar):
        raise TypeError(&#39;`processvar` ({}) must be a (subclass of) &#39; \
            &#39;BaseProcessVariance&#39;.format(type(processvar)))

    if not plu.isarray(initial_conditions):
        raise TypeError(&#39;`initial_conditions` ({}) must be an array&#39;.format( 
            type(initial_conditions)))
    initial_conditions = np.asarray(initial_conditions, dtype=float)
    if initial_conditions.ndim != 2:
        raise ValueError(&#39;`initial_conditions` ({}) must be a column vector&#39;.format( 
            initial_conditions.shape))
    if initial_conditions.shape[1] != 1:
        raise ValueError(&#39;`initial_conditions` ({}) must be a column vector&#39;.format( 
            initial_conditions.shape))

    if not plu.isnumeric(dt):
        raise TypeError(&#39;`dt` ({}) must be a numeric&#39;.format(type(dt)))
    if dt &lt;= 0:
        raise ValueError(&#39;`dt` ({}) must be strictly greater than 0&#39;.format(dt))

    if not plu.isbool(subsample):
        raise TypeError(&#39;`subsample` ({}) must be a bool&#39;.format(type(subsample)))
    
    if not plu.isnumeric(n_days):
        raise TypeError(&#39;`n_days` ({}) must be an int&#39;.format(type(n_days)))
    if n_days &lt;= 0:
        raise ValueError(&#39;`n_days` ({}) must be &gt; 0&#39;.format(n_days))
    
    n_days += dt
    n_timepoints_to_integrate = n_days/dt
    if n_timepoints_to_integrate - int(n_timepoints_to_integrate) != 0:
        n_timepoints_to_integrate = int(n_timepoints_to_integrate)+1
    n_timepoints_to_integrate = int(n_timepoints_to_integrate)
    
    if subsample:
        if times is None:
            times = np.arange(int(n_days), dtype=float)
        elif not plu.isarray(times):
            raise TypeError(&#39;If `subsample` is True, then `times` ({}) must either &#39; \
                &#39;be an array or None&#39;.format(type(times)))
        times = np.asarray(times, dtype=float).ravel()
        times = np.sort(np.unique(times))
        if np.any(times &lt; 0):
            raise ValueError(&#39;All `times` ({}) must be &gt; 0 &#39;.format(times))
        if np.any(times &gt; n_days):
            raise ValueError(&#39;All `times` ({}) must be &lt; `n_days` ({})&#39;.format( 
                times, n_days))
    
    if log_every is None:
        log_every = float(&#39;inf&#39;)
    else:
        if not plu.isint(log_every):
            raise TypeError(&#39;`log_every` ({}) must be an int&#39;.format(type(log_every)))
        if log_every &lt;= 0:
            raise ValueError(&#39;`log_every` ({}) must be &gt;= 0&#39;.format(log_every))

    # Everything is good - initialize then start integrating
    dynamics.init_integration(dt=dt)
    processvar.init_integration()

    X = np.zeros(shape=(initial_conditions.shape[0], n_timepoints_to_integrate), dtype=float)
    X[:,0] = initial_conditions.ravel()

    t = 0
    prev = X[:,[0]]
    for i in range(1,n_timepoints_to_integrate):
        if i % log_every == 0:
            logging.info(&#39;Simulating {}/{}&#39;.format(i, n_timepoints_to_integrate))
        t += dt 
        a = dynamics.integrate_single_timestep(x=prev, t=t, dt=dt)
        X[:,i] = processvar.integrate_single_timestep(x=a, t=t, dt=dt)
        prev = X[:, [i]]
    
    dynamics.finish_integration()
    processvar.finish_integration()

    if subsample:
        steps_per_day = int(n_timepoints_to_integrate/n_days)
        idxs = []
        for t in times:
            idxs.append(int(steps_per_day*t))
        X = X[:, idxs]
    else:
        times = np.arange(n_timepoints_to_integrate, dtype=float) * dt

    return {&#39;X&#39;: X, &#39;times&#39;: times}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mdsine2.pylab.dynamics.integrate"><code class="name flex">
<span>def <span class="ident">integrate</span></span>(<span>dynamics:Â <a title="mdsine2.pylab.dynamics.BaseDynamics" href="#mdsine2.pylab.dynamics.BaseDynamics">BaseDynamics</a>, initial_conditions:Â numpy.ndarray, dt:Â float, n_days:Â float, processvar:Â <a title="mdsine2.pylab.dynamics.BaseProcessVariance" href="#mdsine2.pylab.dynamics.BaseProcessVariance">BaseProcessVariance</a>Â =Â None, subsample:Â boolÂ =Â False, times:Â numpy.ndarrayÂ =Â None, log_every:Â intÂ =Â 10000) â€‘>Â Dict[str,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Numerically integrates the ODE given the dynamics and the initial
conditions. If the process variance is not None, then this integrates
a stochastic ODE.</p>
<h2 id="subsampling">Subsampling</h2>
<p>If the dynamics are complex and the process variance is high, numerical
integration with large time steps can lead to numerical instability, so we
integrate at smaller time steps than what our data is. This smaller time
scale in this function is specified by <code>dt</code>.</p>
<p>We can then subsample our densely integrated trajectories with the flag
<code>subsample</code>. If <code>subsample=False</code>, we return the whole trajectory. If
<code>subsample</code> is True, then we must also specify <code>times</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dynamics</code></strong> :&ensp;<code><a title="mdsine2.pylab.dynamics.BaseDynamics" href="#mdsine2.pylab.dynamics.BaseDynamics">BaseDynamics</a></code></dt>
<dd>These are the dynamics that we want to integrate.</dd>
<dt><strong><code>processvar</code></strong> :&ensp;<code><a title="mdsine2.pylab.dynamics.BaseProcessVariance" href="#mdsine2.pylab.dynamics.BaseProcessVariance">BaseProcessVariance</a>, None</code></dt>
<dd>This is the process variance we want to inject into the integration.
If None, we assume there is no process variance and it is a normal ODE</dd>
<dt><strong><code>initial_conditions</code></strong> :&ensp;<code>np.ndarray((n_taxa,1), dtype=float)</code></dt>
<dd>These are the initial conditions to integrate from. This must be a
column array.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time between each time step (in days) during integration</dd>
<dt><strong><code>n_days</code></strong> :&ensp;<code>float</code></dt>
<dd>How many days to simulate for</dd>
<dt><strong><code>subsample</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, we subsample the integration at the time points indicated in
<code>times</code>. If False we do not subsample</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>int, np.ndarray((t,), dtype=numeric), None</code></dt>
<dd>
<p><code>times</code> must be a list of floats/ints, where each element
corresponds to a time of day to take the sample at. The last time
point must not exceed <code>n_days</code>, each time must be &gt;= 0, and there
must not be duplicates.
Example: (assuming <code>subsample</code> is True)
n_days = 6
times = [0, 0.1, 1.1, 3, 5] - This is valid
times = [0.1, 0, 1.1, 3, 5] - This is valid:
(0 is automatically reordered)
times = [0, 0.1, 1.1, 3, 6] - This is invalid:
(6 is not inclusive)
times = [-0.1, 0, 1.1, 3, 5] - This is invalid:
(-0.1 &lt; 0)
times = [0, 0, 1.1, 3, 5] - This is valid:
(duplicate points for <code>0</code>, but we discard 1)</p>
<p>If <code>subsample</code> is True and <code>times</code> is None, we automatically
return 1 timepoint per day.</p>
</dd>
<dt><strong><code>log_every</code></strong> :&ensp;<code>int, None</code></dt>
<dd>
<ul>
<li>This is how oftent o log the progress of the integration. If None, it
will never log</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>'X': np.ndarray((n_taxa, k), dtype=float)
The abundances for each taxon (row) for each time (column)
'times': np.ndarray((k, ), dtype=float)
These are the times, in days, for each column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate(dynamics: BaseDynamics, initial_conditions: np.ndarray, dt: float, n_days: float, 
    processvar: BaseProcessVariance=None, subsample: bool=False, times: np.ndarray=None, 
    log_every: int=10000) -&gt; Dict[str, np.ndarray]:
    &#39;&#39;&#39;Numerically integrates the ODE given the dynamics and the initial 
    conditions. If the process variance is not None, then this integrates
    a stochastic ODE.

    Subsampling
    -----------
    If the dynamics are complex and the process variance is high, numerical
    integration with large time steps can lead to numerical instability, so we 
    integrate at smaller time steps than what our data is. This smaller time
    scale in this function is specified by `dt`.

    We can then subsample our densely integrated trajectories with the flag
    `subsample`. If `subsample=False`, we return the whole trajectory. If
    `subsample` is True, then we must also specify `times`.

    Parameters
    ----------
    dynamics : BaseDynamics
        These are the dynamics that we want to integrate.
    processvar : BaseProcessVariance, None
        This is the process variance we want to inject into the integration.
        If None, we assume there is no process variance and it is a normal ODE
    initial_conditions : np.ndarray((n_taxa,1), dtype=float)
        These are the initial conditions to integrate from. This must be a 
        column array.
    dt : float
        Time between each time step (in days) during integration
    n_days : float
        How many days to simulate for
    subsample : bool
        If True, we subsample the integration at the time points indicated in
        `times`. If False we do not subsample
    times : int, np.ndarray((t,), dtype=numeric), None
        `times` must be a list of floats/ints, where each element 
        corresponds to a time of day to take the sample at. The last time 
        point must not exceed `n_days`, each time must be &gt;= 0, and there
        must not be duplicates.
        Example: (assuming `subsample` is True)
            n_days = 6
            times = [0, 0.1, 1.1, 3, 5] - This is valid
            times = [0.1, 0, 1.1, 3, 5] - This is valid:
                (0 is automatically reordered)
            times = [0, 0.1, 1.1, 3, 6] - This is invalid: 
                (6 is not inclusive)
            times = [-0.1, 0, 1.1, 3, 5] - This is invalid:
                (-0.1 &lt; 0)
            times = [0, 0, 1.1, 3, 5] - This is valid:
                (duplicate points for `0`, but we discard 1)

        If `subsample` is True and `times` is None, we automatically 
        return 1 timepoint per day.
    log_every : int, None
        - This is how oftent o log the progress of the integration. If None, it 
          will never log

    Returns
    -------
    dict
        &#39;X&#39;: np.ndarray((n_taxa, k), dtype=float)
            The abundances for each taxon (row) for each time (column)
        &#39;times&#39;: np.ndarray((k, ), dtype=float)
            These are the times, in days, for each column
    &#39;&#39;&#39;
    # Type and format checking
    if not isdynamics(dynamics):
        raise TypeError(&#39;`dynamics` ({}) must be a (subclass of) &#39; \
            &#39;BaseDynamics&#39;.format(type(dynamics)))

    if processvar is None:
        processvar = _NoProcessVariance()
    elif not isprocessvariance(processvar):
        raise TypeError(&#39;`processvar` ({}) must be a (subclass of) &#39; \
            &#39;BaseProcessVariance&#39;.format(type(processvar)))

    if not plu.isarray(initial_conditions):
        raise TypeError(&#39;`initial_conditions` ({}) must be an array&#39;.format( 
            type(initial_conditions)))
    initial_conditions = np.asarray(initial_conditions, dtype=float)
    if initial_conditions.ndim != 2:
        raise ValueError(&#39;`initial_conditions` ({}) must be a column vector&#39;.format( 
            initial_conditions.shape))
    if initial_conditions.shape[1] != 1:
        raise ValueError(&#39;`initial_conditions` ({}) must be a column vector&#39;.format( 
            initial_conditions.shape))

    if not plu.isnumeric(dt):
        raise TypeError(&#39;`dt` ({}) must be a numeric&#39;.format(type(dt)))
    if dt &lt;= 0:
        raise ValueError(&#39;`dt` ({}) must be strictly greater than 0&#39;.format(dt))

    if not plu.isbool(subsample):
        raise TypeError(&#39;`subsample` ({}) must be a bool&#39;.format(type(subsample)))
    
    if not plu.isnumeric(n_days):
        raise TypeError(&#39;`n_days` ({}) must be an int&#39;.format(type(n_days)))
    if n_days &lt;= 0:
        raise ValueError(&#39;`n_days` ({}) must be &gt; 0&#39;.format(n_days))
    
    n_days += dt
    n_timepoints_to_integrate = n_days/dt
    if n_timepoints_to_integrate - int(n_timepoints_to_integrate) != 0:
        n_timepoints_to_integrate = int(n_timepoints_to_integrate)+1
    n_timepoints_to_integrate = int(n_timepoints_to_integrate)
    
    if subsample:
        if times is None:
            times = np.arange(int(n_days), dtype=float)
        elif not plu.isarray(times):
            raise TypeError(&#39;If `subsample` is True, then `times` ({}) must either &#39; \
                &#39;be an array or None&#39;.format(type(times)))
        times = np.asarray(times, dtype=float).ravel()
        times = np.sort(np.unique(times))
        if np.any(times &lt; 0):
            raise ValueError(&#39;All `times` ({}) must be &gt; 0 &#39;.format(times))
        if np.any(times &gt; n_days):
            raise ValueError(&#39;All `times` ({}) must be &lt; `n_days` ({})&#39;.format( 
                times, n_days))
    
    if log_every is None:
        log_every = float(&#39;inf&#39;)
    else:
        if not plu.isint(log_every):
            raise TypeError(&#39;`log_every` ({}) must be an int&#39;.format(type(log_every)))
        if log_every &lt;= 0:
            raise ValueError(&#39;`log_every` ({}) must be &gt;= 0&#39;.format(log_every))

    # Everything is good - initialize then start integrating
    dynamics.init_integration(dt=dt)
    processvar.init_integration()

    X = np.zeros(shape=(initial_conditions.shape[0], n_timepoints_to_integrate), dtype=float)
    X[:,0] = initial_conditions.ravel()

    t = 0
    prev = X[:,[0]]
    for i in range(1,n_timepoints_to_integrate):
        if i % log_every == 0:
            logging.info(&#39;Simulating {}/{}&#39;.format(i, n_timepoints_to_integrate))
        t += dt 
        a = dynamics.integrate_single_timestep(x=prev, t=t, dt=dt)
        X[:,i] = processvar.integrate_single_timestep(x=a, t=t, dt=dt)
        prev = X[:, [i]]
    
    dynamics.finish_integration()
    processvar.finish_integration()

    if subsample:
        steps_per_day = int(n_timepoints_to_integrate/n_days)
        idxs = []
        for t in times:
            idxs.append(int(steps_per_day*t))
        X = X[:, idxs]
    else:
        times = np.arange(n_timepoints_to_integrate, dtype=float) * dt

    return {&#39;X&#39;: X, &#39;times&#39;: times}</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.dynamics.isdynamics"><code class="name flex">
<span>def <span class="ident">isdynamics</span></span>(<span>x:Â Any) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if <code>a</code> is a (subclass of) BaseDynamics</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Instance we are checking</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is a subclass of a BaseDynamics</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdynamics(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks if `a` is a (subclass of) BaseDynamics

    Parameters
    ----------
    x : any
        Instance we are checking

    Returns
    -------
    bool
        True if `x` is a subclass of a BaseDynamics
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, BaseDynamics)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.dynamics.isintegratable"><code class="name flex">
<span>def <span class="ident">isintegratable</span></span>(<span>x:Â Any) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if <code>a</code> is a (subclass of) Integratable</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Instance we are checking</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is a subclass of a Integratable</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isintegratable(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks if `a` is a (subclass of) Integratable

    Parameters
    ----------
    x : any
        Instance we are checking

    Returns
    -------
    bool
        True if `x` is a subclass of a Integratable
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, Integratable)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.dynamics.isprocessvariance"><code class="name flex">
<span>def <span class="ident">isprocessvariance</span></span>(<span>x:Â Any) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if <code>a</code> is a (subclass of) ProcessVariance</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Instance we are checking</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is a subclass of a BaseProcessVariance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isprocessvariance(x: Any) -&gt; bool:
    &#39;&#39;&#39;Checks if `a` is a (subclass of) ProcessVariance

    Parameters
    ----------
    x : any
        Instance we are checking

    Returns
    -------
    bool
        True if `x` is a subclass of a BaseProcessVariance
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, BaseProcessVariance)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdsine2.pylab.dynamics.BaseDynamics"><code class="flex name class">
<span>class <span class="ident">BaseDynamics</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the base class for the dynamics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseDynamics(Integratable):
    &#39;&#39;&#39;This is the base class for the dynamics
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        Integratable.__init__(self, **kwargs)

    def stability(self):
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def integrate(self, *args, **kwargs):
        return integrate(dynamics=self, *args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.dynamics.Integratable" href="#mdsine2.pylab.dynamics.Integratable">Integratable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.model.gLVDynamicsSingleClustering" href="../model.html#mdsine2.model.gLVDynamicsSingleClustering">gLVDynamicsSingleClustering</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.dynamics.BaseDynamics.integrate"><code class="name flex">
<span>def <span class="ident">integrate</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate(self, *args, **kwargs):
    return integrate(dynamics=self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.dynamics.BaseDynamics.stability"><code class="name flex">
<span>def <span class="ident">stability</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stability(self):
    raise NeedToImplementError(&#39;User needs to implement this function&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.dynamics.Integratable" href="#mdsine2.pylab.dynamics.Integratable">Integratable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.dynamics.Integratable.finish_integration" href="#mdsine2.pylab.dynamics.Integratable.finish_integration">finish_integration</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.Integratable.init_integration" href="#mdsine2.pylab.dynamics.Integratable.init_integration">init_integration</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.Integratable.integrate_single_timestep" href="#mdsine2.pylab.dynamics.Integratable.integrate_single_timestep">integrate_single_timestep</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.dynamics.BaseProcessVariance"><code class="flex name class">
<span>class <span class="ident">BaseProcessVariance</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseProcessVariance(Integratable):
    &#39;&#39;&#39;
    &#39;&#39;&#39;
    def __init__(self, *args, **kwargs):
        Integratable.__init__(self, *args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.dynamics.Integratable" href="#mdsine2.pylab.dynamics.Integratable">Integratable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.model.MultiplicativeGlobal" href="../model.html#mdsine2.model.MultiplicativeGlobal">MultiplicativeGlobal</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.dynamics.Integratable" href="#mdsine2.pylab.dynamics.Integratable">Integratable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.dynamics.Integratable.finish_integration" href="#mdsine2.pylab.dynamics.Integratable.finish_integration">finish_integration</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.Integratable.init_integration" href="#mdsine2.pylab.dynamics.Integratable.init_integration">init_integration</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.Integratable.integrate_single_timestep" href="#mdsine2.pylab.dynamics.Integratable.integrate_single_timestep">integrate_single_timestep</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.dynamics.Integratable"><code class="flex name class">
<span>class <span class="ident">Integratable</span></span>
</code></dt>
<dd>
<div class="desc"><p>These are the functions needed for integrating</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Integratable:
    &#39;&#39;&#39;These are the functions needed for integrating
    &#39;&#39;&#39;  
    def init_integration(self):
        &#39;&#39;&#39;This is the function that `integrate` calls to start the integration
        &#39;&#39;&#39;
        pass

    def integrate_single_timestep(self, x: np.ndarray, t: float, dt: float):
        &#39;&#39;&#39;This is the function that `integrate` calls to propagate the underlying
        dynamics a single time step. There is no type checking for computational
        efficiency

        Parameters
        ----------
        x : np.ndarray((n,1))
            This is the abundance as a column vector for each taxon
        t : numeric
            This is the time point we are integrating to
        dt : numeric
            This is the amount of time from the previous time point we
            are integrating from
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def finish_integration(self):
        &#39;&#39;&#39;This is the function that
        &#39;&#39;&#39;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.dynamics.BaseDynamics" href="#mdsine2.pylab.dynamics.BaseDynamics">BaseDynamics</a></li>
<li><a title="mdsine2.pylab.dynamics.BaseProcessVariance" href="#mdsine2.pylab.dynamics.BaseProcessVariance">BaseProcessVariance</a></li>
<li>mdsine2.pylab.dynamics._NoProcessVariance</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.dynamics.Integratable.finish_integration"><code class="name flex">
<span>def <span class="ident">finish_integration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the function that</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_integration(self):
    &#39;&#39;&#39;This is the function that
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.dynamics.Integratable.init_integration"><code class="name flex">
<span>def <span class="ident">init_integration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the function that <code><a title="mdsine2.pylab.dynamics.integrate" href="#mdsine2.pylab.dynamics.integrate">integrate()</a></code> calls to start the integration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_integration(self):
    &#39;&#39;&#39;This is the function that `integrate` calls to start the integration
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.dynamics.Integratable.integrate_single_timestep"><code class="name flex">
<span>def <span class="ident">integrate_single_timestep</span></span>(<span>self, x:Â numpy.ndarray, t:Â float, dt:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the function that <code><a title="mdsine2.pylab.dynamics.integrate" href="#mdsine2.pylab.dynamics.integrate">integrate()</a></code> calls to propagate the underlying
dynamics a single time step. There is no type checking for computational
efficiency</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray((n,1))</code></dt>
<dd>This is the abundance as a column vector for each taxon</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>numeric</code></dt>
<dd>This is the time point we are integrating to</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>numeric</code></dt>
<dd>This is the amount of time from the previous time point we
are integrating from</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate_single_timestep(self, x: np.ndarray, t: float, dt: float):
    &#39;&#39;&#39;This is the function that `integrate` calls to propagate the underlying
    dynamics a single time step. There is no type checking for computational
    efficiency

    Parameters
    ----------
    x : np.ndarray((n,1))
        This is the abundance as a column vector for each taxon
    t : numeric
        This is the time point we are integrating to
    dt : numeric
        This is the amount of time from the previous time point we
        are integrating from
    &#39;&#39;&#39;
    raise NeedToImplementError(&#39;User needs to implement this function&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdsine2.pylab" href="index.html">mdsine2.pylab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mdsine2.pylab.dynamics.integrate" href="#mdsine2.pylab.dynamics.integrate">integrate</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.isdynamics" href="#mdsine2.pylab.dynamics.isdynamics">isdynamics</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.isintegratable" href="#mdsine2.pylab.dynamics.isintegratable">isintegratable</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.isprocessvariance" href="#mdsine2.pylab.dynamics.isprocessvariance">isprocessvariance</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdsine2.pylab.dynamics.BaseDynamics" href="#mdsine2.pylab.dynamics.BaseDynamics">BaseDynamics</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.dynamics.BaseDynamics.integrate" href="#mdsine2.pylab.dynamics.BaseDynamics.integrate">integrate</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.BaseDynamics.stability" href="#mdsine2.pylab.dynamics.BaseDynamics.stability">stability</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.dynamics.BaseProcessVariance" href="#mdsine2.pylab.dynamics.BaseProcessVariance">BaseProcessVariance</a></code></h4>
</li>
<li>
<h4><code><a title="mdsine2.pylab.dynamics.Integratable" href="#mdsine2.pylab.dynamics.Integratable">Integratable</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.dynamics.Integratable.finish_integration" href="#mdsine2.pylab.dynamics.Integratable.finish_integration">finish_integration</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.Integratable.init_integration" href="#mdsine2.pylab.dynamics.Integratable.init_integration">init_integration</a></code></li>
<li><code><a title="mdsine2.pylab.dynamics.Integratable.integrate_single_timestep" href="#mdsine2.pylab.dynamics.Integratable.integrate_single_timestep">integrate_single_timestep</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>